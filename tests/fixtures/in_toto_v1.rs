//! This file is generated by typify through Spector. Do not edit it directly.
//! Exceptions to this rule are for cases where typify doesn't genrate the correct code.
#![allow(clippy::all)]
#![allow(warnings)]
use serde::{Deserialize, Serialize};
///A struct
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct Attribute {
    pub attribute: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<std::collections::HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub evidence: Option<ResourceDescriptor>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub target: Option<ResourceDescriptor>,
}
impl From<&Attribute> for Attribute {
    fn from(value: &Attribute) -> Self {
        value.clone()
    }
}
impl Attribute {
    pub fn builder() -> builder::Attribute {
        builder::Attribute::default()
    }
}
///A structure representing the build definition of the SLSA Provenance v1 Predicate.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct BuildDefinition {
    #[serde(rename = "buildType")]
    pub build_type: String,
    ///The parameters that are under external control, such as those set by a user or tenant of the build platform. They MUST be complete at SLSA Build L3, meaning that there is no additional mechanism for an external party to influence the build. (At lower SLSA Build levels, the completeness MAY be best effort.)\nThe build platform SHOULD be designed to minimize the size and complexity of externalParameters, in order to reduce fragility and ease verification. Consumers SHOULD have an expectation of what “good” looks like; the more information that they need to check, the harder that task becomes.\nVerifiers SHOULD reject unrecognized or unexpected fields within externalParameters.
    #[serde(rename = "externalParameters")]
    pub external_parameters: serde_json::Map<String, serde_json::Value>,
    ///Unordered collection of artifacts needed at build time. Completeness is best effort, at least through SLSA Build L3. For example, if the build script fetches and executes “example.com/foo.sh”, which in turn fetches “example.com/bar.tar.gz”, then both “foo.sh” and “bar.tar.gz” SHOULD be listed here.
    #[serde(
        rename = "internalParameters",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub internal_parameters: Option<serde_json::Map<String, serde_json::Value>>,
    ///Unordered collection of artifacts needed at build time. Completeness is best effort, at least through SLSA Build L3. For example, if the build script fetches and executes “example.com/foo.sh”, which in turn fetches “example.com/bar.tar.gz”, then both “foo.sh” and “bar.tar.gz” SHOULD be listed here.
    #[serde(
        rename = "resolvedDependencies",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub resolved_dependencies: Option<Vec<ResourceDescriptor>>,
}
impl From<&BuildDefinition> for BuildDefinition {
    fn from(value: &BuildDefinition) -> Self {
        value.clone()
    }
}
impl BuildDefinition {
    pub fn builder() -> builder::BuildDefinition {
        builder::BuildDefinition::default()
    }
}
///A structure representing the metadata of the SLSA Provenance v1 Predicate.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct BuildMetadata {
    ///The timestamp of when the build completed.
    #[serde(rename = "finishedOn", default, skip_serializing_if = "Option::is_none")]
    pub finished_on: Option<chrono::DateTime<chrono::offset::Utc>>,
    ///Identifies this particular build invocation, which can be useful for finding associated logs or other ad-hoc analysis. The exact meaning and format is defined by builder.id; by default it is treated as opaque and case-sensitive. The value SHOULD be globally unique.
    #[serde(rename = "invocationId", default, skip_serializing_if = "Option::is_none")]
    pub invocation_id: Option<String>,
    ///The timestamp of when the build started.
    #[serde(rename = "startedOn", default, skip_serializing_if = "Option::is_none")]
    pub started_on: Option<chrono::DateTime<chrono::offset::Utc>>,
}
impl From<&BuildMetadata> for BuildMetadata {
    fn from(value: &BuildMetadata) -> Self {
        value.clone()
    }
}
impl BuildMetadata {
    pub fn builder() -> builder::BuildMetadata {
        builder::BuildMetadata::default()
    }
}
///A structure representing the metadata of the SLSA Provenance v0.2 Predicate.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct BuildMetadata2 {
    ///The timestamp of when the build completed.
    #[serde(
        rename = "buildFinishedOn",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub build_finished_on: Option<chrono::DateTime<chrono::offset::Utc>>,
    ///Identifies this particular build invocation, which can be useful for finding associated logs or other ad-hoc analysis. The exact meaning and format is defined by builder.id; by default it is treated as opaque and case-sensitive. The value SHOULD be globally unique.
    #[serde(
        rename = "buildInvocationId",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub build_invocation_id: Option<String>,
    ///The timestamp of when the build started.
    #[serde(rename = "buildStartedOn", default, skip_serializing_if = "Option::is_none")]
    pub build_started_on: Option<chrono::DateTime<chrono::offset::Utc>>,
    ///Information on how complete the provided information is.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completeness: Option<Completeness>,
    ///Whether the builder claims that running invocation on materials will produce bit-for-bit identical output.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reproducible: Option<bool>,
}
impl From<&BuildMetadata2> for BuildMetadata2 {
    fn from(value: &BuildMetadata2) -> Self {
        value.clone()
    }
}
impl BuildMetadata2 {
    pub fn builder() -> builder::BuildMetadata2 {
        builder::BuildMetadata2::default()
    }
}
///A structure representing the builder information of the SLSA Provenance v1 Predicate.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct Builder {
    #[serde(
        rename = "builderDependencies",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub builder_dependencies: Option<Vec<ResourceDescriptor>>,
    pub id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}
impl From<&Builder> for Builder {
    fn from(value: &Builder) -> Self {
        value.clone()
    }
}
impl Builder {
    pub fn builder() -> builder::Builder {
        builder::Builder::default()
    }
}
///A structure representing the builder information of the SLSA Provenance v0.2 Predicate.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct Builder2 {
    pub id: String,
}
impl From<&Builder2> for Builder2 {
    fn from(value: &Builder2) -> Self {
        value.clone()
    }
}
impl Builder2 {
    pub fn builder() -> builder::Builder2 {
        builder::Builder2::default()
    }
}
///A structure representing the completeness claims of the SLSA Provenance v0.2 Predicate.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct Completeness {
    ///Whether the builder claims that invocation.environment is complete.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub environment: Option<bool>,
    ///Whether the builder claims that materials is complete, usually through some controls to prevent network access.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub materials: Option<bool>,
    ///Whether the builder claims that nvocation.parameters is complete, meaning that all external inputs are properly captured in invocation.parameters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parameters: Option<bool>,
}
impl From<&Completeness> for Completeness {
    fn from(value: &Completeness) -> Self {
        value.clone()
    }
}
impl Completeness {
    pub fn builder() -> builder::Completeness {
        builder::Completeness::default()
    }
}
///A structure representing the description of where the config file that kicked off the build came from in the SLSA Provenance v0.2 Predicate.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct ConfigSource {
    ///A set of cryptographic digests of the contents of the resource or artifact.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub digest: Option<std::collections::HashMap<String, String>>,
    ///The entry point into the build. This is often a path to a configuration file and/or a target label within that file.
    #[serde(rename = "entryPoint", default, skip_serializing_if = "Option::is_none")]
    pub entry_point: Option<String>,
    ///The identity of the source of the config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}
impl From<&ConfigSource> for ConfigSource {
    fn from(value: &ConfigSource) -> Self {
        value.clone()
    }
}
impl ConfigSource {
    pub fn builder() -> builder::ConfigSource {
        builder::ConfigSource::default()
    }
}
///Represents a set of digests, mapping algorithms to their respective digest strings.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct DigestSet(pub std::collections::HashMap<String, String>);
impl std::ops::Deref for DigestSet {
    type Target = std::collections::HashMap<String, String>;
    fn deref(&self) -> &std::collections::HashMap<String, String> {
        &self.0
    }
}
impl From<DigestSet> for std::collections::HashMap<String, String> {
    fn from(value: DigestSet) -> Self {
        value.0
    }
}
impl From<&DigestSet> for DigestSet {
    fn from(value: &DigestSet) -> Self {
        value.clone()
    }
}
impl From<std::collections::HashMap<String, String>> for DigestSet {
    fn from(value: std::collections::HashMap<String, String>) -> Self {
        Self(value)
    }
}
///Represents an In-Toto v1 statement.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct InTotoStatementV1ForPredicate {
    pub predicate: Predicate,
    #[serde(rename = "predicateType")]
    pub predicate_type: String,
    pub subject: Vec<Subject>,
    #[serde(rename = "_type")]
    pub type_: String,
}
impl From<&InTotoStatementV1ForPredicate> for InTotoStatementV1ForPredicate {
    fn from(value: &InTotoStatementV1ForPredicate) -> Self {
        value.clone()
    }
}
impl InTotoStatementV1ForPredicate {
    pub fn builder() -> builder::InTotoStatementV1ForPredicate {
        builder::InTotoStatementV1ForPredicate::default()
    }
}
///A structure identifying the event that kicked off the build in the SLSA Provenance v0.2 Predicate.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct Invocation {
    ///Description of where the config file that kicked off the build came from. This is effectively a pointer to the source where buildConfig came from.
    #[serde(rename = "configSource", default, skip_serializing_if = "Option::is_none")]
    pub config_source: Option<ConfigSource>,
    ///Any other builder-controlled inputs necessary for correctly evaluating the build. Usually only needed for reproducing the build but not evaluated as part of policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub environment: Option<serde_json::Map<String, serde_json::Value>>,
    ///Collection of all external inputs that influenced the build on top of invocation.configSource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parameters: Option<serde_json::Map<String, serde_json::Value>>,
}
impl From<&Invocation> for Invocation {
    fn from(value: &Invocation) -> Self {
        value.clone()
    }
}
impl Invocation {
    pub fn builder() -> builder::Invocation {
        builder::Invocation::default()
    }
}
/**An enum representing different predicate types.

Known predicate types have their own variants, while unknown types are represented by the `Other` variant, which stores the raw JSON value.

TODO(mlieberman85): Support (de)serializing the predicates based on the predicateType URL in the statement.*/
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct Predicate {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<SlsaProvenanceV1Predicate>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<SlsaProvenanceV02Predicate>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<Scaiv02Predicate>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<serde_json::Value>,
}
impl From<&Predicate> for Predicate {
    fn from(value: &Predicate) -> Self {
        value.clone()
    }
}
impl Predicate {
    pub fn builder() -> builder::Predicate {
        builder::Predicate::default()
    }
}
///A size-efficient description of any software artifact or resource (mutable or immutable).
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct ResourceDescriptor {
    ///This field MAY be used to provide additional information or metadata about the resource or artifact that may be useful to the consumer when evaluating the attestation against a policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<serde_json::Map<String, serde_json::Value>>,
    ///The contents of the resource or artifact. This field is REQUIRED unless either uri or digest is set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content: Option<String>,
    ///A set of cryptographic digests of the contents of the resource or artifact. This field is REQUIRED unless either uri or content is set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub digest: Option<std::collections::HashMap<String, String>>,
    ///The location of the described resource or artifact, if different from the uri.
    #[serde(
        rename = "downloadLocation",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub download_location: Option<String>,
    ///The MIME Type (i.e., media type) of the described resource or artifact.
    #[serde(rename = "mediaType", default, skip_serializing_if = "Option::is_none")]
    pub media_type: Option<String>,
    ///Machine-readable identifier for distinguishing between descriptors.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    ///A URI used to identify the resource or artifact globally. This field is REQUIRED unless either digest or content is set.
    pub uri: String,
}
impl From<&ResourceDescriptor> for ResourceDescriptor {
    fn from(value: &ResourceDescriptor) -> Self {
        value.clone()
    }
}
impl ResourceDescriptor {
    pub fn builder() -> builder::ResourceDescriptor {
        builder::ResourceDescriptor::default()
    }
}
///A size-efficient description of any software artifact or resource (mutable or immutable).
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct ResourceDescriptor2 {
    ///A set of cryptographic digests of the contents of the resource or artifact. This field is REQUIRED unless uri is set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub digest: Option<std::collections::HashMap<String, String>>,
    ///A URI used to identify the resource or artifact globally. This field is REQUIRED unless digest is set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}
impl From<&ResourceDescriptor2> for ResourceDescriptor2 {
    fn from(value: &ResourceDescriptor2) -> Self {
        value.clone()
    }
}
impl ResourceDescriptor2 {
    pub fn builder() -> builder::ResourceDescriptor2 {
        builder::ResourceDescriptor2::default()
    }
}
///A structure representing the run details of the SLSA Provenance v1 Predicate.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct RunDetails {
    ///Identifies the build platform that executed the invocation, which is trusted to have correctly performed the operation and populated this provenance.
    pub builder: Builder,
    ///Additional artifacts generated during the build that are not considered the “output” of the build but that might be needed during debugging or incident response. For example, this might reference logs generated during the build and/or a digest of the fully evaluated build configuration.\nIn most cases, this SHOULD NOT contain all intermediate files generated during the build. Instead, this SHOULD only contain files that are likely to be useful later and that cannot be easily reproduced.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub byproducts: Option<Vec<ResourceDescriptor>>,
    ///metadata about this particular execution of the build.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<BuildMetadata>,
}
impl From<&RunDetails> for RunDetails {
    fn from(value: &RunDetails) -> Self {
        value.clone()
    }
}
impl RunDetails {
    pub fn builder() -> builder::RunDetails {
        builder::RunDetails::default()
    }
}
///This is based on the model in: { "predicateType": "https://in-toto.io/attestation/scai/attribute-report/v0.2", "predicate": { "attributes": [{ "attribute": "<ATTRIBUTE>", "target": { [ResourceDescriptor] }, // optional "conditions": { /* object */ }, // optional "evidence": { [ResourceDescriptor] } // optional }], "producer": { [ResourceDescriptor] } // optional } } A struct representing the SCAI V0.2 Predicate.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct Scaiv02Predicate {
    pub attributes: Vec<Attribute>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub producer: Option<ResourceDescriptor>,
}
impl From<&Scaiv02Predicate> for Scaiv02Predicate {
    fn from(value: &Scaiv02Predicate) -> Self {
        value.clone()
    }
}
impl Scaiv02Predicate {
    pub fn builder() -> builder::Scaiv02Predicate {
        builder::Scaiv02Predicate::default()
    }
}
///A structure representing the SLSA Provenance v0.2 Predicate.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct SlsaProvenanceV02Predicate {
    ///The steps in the build. If invocation.configSource is not available, buildConfig can be used to verify information about the build.
    #[serde(rename = "buildConfig", default, skip_serializing_if = "Option::is_none")]
    pub build_config: Option<serde_json::Map<String, serde_json::Value>>,
    ///The type of build that was performed.
    #[serde(rename = "buildType")]
    pub build_type: String,
    ///The entity that executed the invocation, which is trusted to have correctly performed the operation and populated this provenance.
    pub builder: Builder2,
    ///The event that kicked off the build.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub invocation: Option<Invocation>,
    ///Unordered collection of artifacts that influenced the build including sources, dependencies, build tools, base images, and so on. Completeness is best effort, at least through SLSA Build L3. For example, if the build script fetches and executes “example.com/foo.sh”, which in turn fetches “example.com/bar.tar.gz”, then both “foo.sh” and “bar.tar.gz” SHOULD be listed here.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub materials: Option<Vec<ResourceDescriptor2>>,
    ///Metadata about this particular execution of the build.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<BuildMetadata2>,
}
impl From<&SlsaProvenanceV02Predicate> for SlsaProvenanceV02Predicate {
    fn from(value: &SlsaProvenanceV02Predicate) -> Self {
        value.clone()
    }
}
impl SlsaProvenanceV02Predicate {
    pub fn builder() -> builder::SlsaProvenanceV02Predicate {
        builder::SlsaProvenanceV02Predicate::default()
    }
}
///A structure representing the SLSA Provenance v1 Predicate.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct SlsaProvenanceV1Predicate {
    #[serde(rename = "buildDefinition")]
    pub build_definition: BuildDefinition,
    #[serde(rename = "runDetails")]
    pub run_details: RunDetails,
}
impl From<&SlsaProvenanceV1Predicate> for SlsaProvenanceV1Predicate {
    fn from(value: &SlsaProvenanceV1Predicate) -> Self {
        value.clone()
    }
}
impl SlsaProvenanceV1Predicate {
    pub fn builder() -> builder::SlsaProvenanceV1Predicate {
        builder::SlsaProvenanceV1Predicate::default()
    }
}
///Represents a subject in an In-Toto v1 statement.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct Subject {
    pub digest: DigestSet,
    pub name: String,
}
impl From<&Subject> for Subject {
    fn from(value: &Subject) -> Self {
        value.clone()
    }
}
impl Subject {
    pub fn builder() -> builder::Subject {
        builder::Subject::default()
    }
}
pub mod builder {
    #[derive(Clone, Debug)]
    pub struct Attribute {
        attribute: Result<String, String>,
        conditions: Result<Option<std::collections::HashMap<String, String>>, String>,
        evidence: Result<Option<super::ResourceDescriptor>, String>,
        target: Result<Option<super::ResourceDescriptor>, String>,
    }
    impl Default for Attribute {
        fn default() -> Self {
            Self {
                attribute: Err("no value supplied for attribute".to_string()),
                conditions: Ok(Default::default()),
                evidence: Ok(Default::default()),
                target: Ok(Default::default()),
            }
        }
    }
    impl Attribute {
        pub fn attribute<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .attribute = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for attribute: {}", e)
                });
            self
        }
        pub fn conditions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<std::collections::HashMap<String, String>>>,
            T::Error: std::fmt::Display,
        {
            self
                .conditions = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for conditions: {}", e)
                });
            self
        }
        pub fn evidence<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ResourceDescriptor>>,
            T::Error: std::fmt::Display,
        {
            self
                .evidence = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for evidence: {}", e)
                });
            self
        }
        pub fn target<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ResourceDescriptor>>,
            T::Error: std::fmt::Display,
        {
            self
                .target = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for target: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Attribute> for super::Attribute {
        type Error = String;
        fn try_from(value: Attribute) -> Result<Self, String> {
            Ok(Self {
                attribute: value.attribute?,
                conditions: value.conditions?,
                evidence: value.evidence?,
                target: value.target?,
            })
        }
    }
    impl From<super::Attribute> for Attribute {
        fn from(value: super::Attribute) -> Self {
            Self {
                attribute: Ok(value.attribute),
                conditions: Ok(value.conditions),
                evidence: Ok(value.evidence),
                target: Ok(value.target),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BuildDefinition {
        build_type: Result<String, String>,
        external_parameters: Result<serde_json::Map<String, serde_json::Value>, String>,
        internal_parameters: Result<
            Option<serde_json::Map<String, serde_json::Value>>,
            String,
        >,
        resolved_dependencies: Result<Option<Vec<super::ResourceDescriptor>>, String>,
    }
    impl Default for BuildDefinition {
        fn default() -> Self {
            Self {
                build_type: Err("no value supplied for build_type".to_string()),
                external_parameters: Err(
                    "no value supplied for external_parameters".to_string(),
                ),
                internal_parameters: Ok(Default::default()),
                resolved_dependencies: Ok(Default::default()),
            }
        }
    }
    impl BuildDefinition {
        pub fn build_type<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .build_type = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for build_type: {}", e)
                });
            self
        }
        pub fn external_parameters<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<serde_json::Map<String, serde_json::Value>>,
            T::Error: std::fmt::Display,
        {
            self
                .external_parameters = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for external_parameters: {}", e
                    )
                });
            self
        }
        pub fn internal_parameters<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<serde_json::Map<String, serde_json::Value>>>,
            T::Error: std::fmt::Display,
        {
            self
                .internal_parameters = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for internal_parameters: {}", e
                    )
                });
            self
        }
        pub fn resolved_dependencies<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<Vec<super::ResourceDescriptor>>>,
            T::Error: std::fmt::Display,
        {
            self
                .resolved_dependencies = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for resolved_dependencies: {}",
                        e
                    )
                });
            self
        }
    }
    impl std::convert::TryFrom<BuildDefinition> for super::BuildDefinition {
        type Error = String;
        fn try_from(value: BuildDefinition) -> Result<Self, String> {
            Ok(Self {
                build_type: value.build_type?,
                external_parameters: value.external_parameters?,
                internal_parameters: value.internal_parameters?,
                resolved_dependencies: value.resolved_dependencies?,
            })
        }
    }
    impl From<super::BuildDefinition> for BuildDefinition {
        fn from(value: super::BuildDefinition) -> Self {
            Self {
                build_type: Ok(value.build_type),
                external_parameters: Ok(value.external_parameters),
                internal_parameters: Ok(value.internal_parameters),
                resolved_dependencies: Ok(value.resolved_dependencies),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BuildMetadata {
        finished_on: Result<Option<chrono::DateTime<chrono::offset::Utc>>, String>,
        invocation_id: Result<Option<String>, String>,
        started_on: Result<Option<chrono::DateTime<chrono::offset::Utc>>, String>,
    }
    impl Default for BuildMetadata {
        fn default() -> Self {
            Self {
                finished_on: Ok(Default::default()),
                invocation_id: Ok(Default::default()),
                started_on: Ok(Default::default()),
            }
        }
    }
    impl BuildMetadata {
        pub fn finished_on<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<chrono::DateTime<chrono::offset::Utc>>>,
            T::Error: std::fmt::Display,
        {
            self
                .finished_on = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for finished_on: {}", e)
                });
            self
        }
        pub fn invocation_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .invocation_id = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for invocation_id: {}", e)
                });
            self
        }
        pub fn started_on<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<chrono::DateTime<chrono::offset::Utc>>>,
            T::Error: std::fmt::Display,
        {
            self
                .started_on = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for started_on: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<BuildMetadata> for super::BuildMetadata {
        type Error = String;
        fn try_from(value: BuildMetadata) -> Result<Self, String> {
            Ok(Self {
                finished_on: value.finished_on?,
                invocation_id: value.invocation_id?,
                started_on: value.started_on?,
            })
        }
    }
    impl From<super::BuildMetadata> for BuildMetadata {
        fn from(value: super::BuildMetadata) -> Self {
            Self {
                finished_on: Ok(value.finished_on),
                invocation_id: Ok(value.invocation_id),
                started_on: Ok(value.started_on),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BuildMetadata2 {
        build_finished_on: Result<Option<chrono::DateTime<chrono::offset::Utc>>, String>,
        build_invocation_id: Result<Option<String>, String>,
        build_started_on: Result<Option<chrono::DateTime<chrono::offset::Utc>>, String>,
        completeness: Result<Option<super::Completeness>, String>,
        reproducible: Result<Option<bool>, String>,
    }
    impl Default for BuildMetadata2 {
        fn default() -> Self {
            Self {
                build_finished_on: Ok(Default::default()),
                build_invocation_id: Ok(Default::default()),
                build_started_on: Ok(Default::default()),
                completeness: Ok(Default::default()),
                reproducible: Ok(Default::default()),
            }
        }
    }
    impl BuildMetadata2 {
        pub fn build_finished_on<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<chrono::DateTime<chrono::offset::Utc>>>,
            T::Error: std::fmt::Display,
        {
            self
                .build_finished_on = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for build_finished_on: {}", e
                    )
                });
            self
        }
        pub fn build_invocation_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .build_invocation_id = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for build_invocation_id: {}", e
                    )
                });
            self
        }
        pub fn build_started_on<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<chrono::DateTime<chrono::offset::Utc>>>,
            T::Error: std::fmt::Display,
        {
            self
                .build_started_on = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for build_started_on: {}", e
                    )
                });
            self
        }
        pub fn completeness<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::Completeness>>,
            T::Error: std::fmt::Display,
        {
            self
                .completeness = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for completeness: {}", e)
                });
            self
        }
        pub fn reproducible<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<bool>>,
            T::Error: std::fmt::Display,
        {
            self
                .reproducible = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for reproducible: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<BuildMetadata2> for super::BuildMetadata2 {
        type Error = String;
        fn try_from(value: BuildMetadata2) -> Result<Self, String> {
            Ok(Self {
                build_finished_on: value.build_finished_on?,
                build_invocation_id: value.build_invocation_id?,
                build_started_on: value.build_started_on?,
                completeness: value.completeness?,
                reproducible: value.reproducible?,
            })
        }
    }
    impl From<super::BuildMetadata2> for BuildMetadata2 {
        fn from(value: super::BuildMetadata2) -> Self {
            Self {
                build_finished_on: Ok(value.build_finished_on),
                build_invocation_id: Ok(value.build_invocation_id),
                build_started_on: Ok(value.build_started_on),
                completeness: Ok(value.completeness),
                reproducible: Ok(value.reproducible),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Builder {
        builder_dependencies: Result<Option<Vec<super::ResourceDescriptor>>, String>,
        id: Result<String, String>,
        version: Result<Option<String>, String>,
    }
    impl Default for Builder {
        fn default() -> Self {
            Self {
                builder_dependencies: Ok(Default::default()),
                id: Err("no value supplied for id".to_string()),
                version: Ok(Default::default()),
            }
        }
    }
    impl Builder {
        pub fn builder_dependencies<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<Vec<super::ResourceDescriptor>>>,
            T::Error: std::fmt::Display,
        {
            self
                .builder_dependencies = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for builder_dependencies: {}", e
                    )
                });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn version<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .version = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for version: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Builder> for super::Builder {
        type Error = String;
        fn try_from(value: Builder) -> Result<Self, String> {
            Ok(Self {
                builder_dependencies: value.builder_dependencies?,
                id: value.id?,
                version: value.version?,
            })
        }
    }
    impl From<super::Builder> for Builder {
        fn from(value: super::Builder) -> Self {
            Self {
                builder_dependencies: Ok(value.builder_dependencies),
                id: Ok(value.id),
                version: Ok(value.version),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Builder2 {
        id: Result<String, String>,
    }
    impl Default for Builder2 {
        fn default() -> Self {
            Self {
                id: Err("no value supplied for id".to_string()),
            }
        }
    }
    impl Builder2 {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
    }
    impl std::convert::TryFrom<Builder2> for super::Builder2 {
        type Error = String;
        fn try_from(value: Builder2) -> Result<Self, String> {
            Ok(Self { id: value.id? })
        }
    }
    impl From<super::Builder2> for Builder2 {
        fn from(value: super::Builder2) -> Self {
            Self { id: Ok(value.id) }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Completeness {
        environment: Result<Option<bool>, String>,
        materials: Result<Option<bool>, String>,
        parameters: Result<Option<bool>, String>,
    }
    impl Default for Completeness {
        fn default() -> Self {
            Self {
                environment: Ok(Default::default()),
                materials: Ok(Default::default()),
                parameters: Ok(Default::default()),
            }
        }
    }
    impl Completeness {
        pub fn environment<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<bool>>,
            T::Error: std::fmt::Display,
        {
            self
                .environment = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for environment: {}", e)
                });
            self
        }
        pub fn materials<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<bool>>,
            T::Error: std::fmt::Display,
        {
            self
                .materials = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for materials: {}", e)
                });
            self
        }
        pub fn parameters<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<bool>>,
            T::Error: std::fmt::Display,
        {
            self
                .parameters = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for parameters: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Completeness> for super::Completeness {
        type Error = String;
        fn try_from(value: Completeness) -> Result<Self, String> {
            Ok(Self {
                environment: value.environment?,
                materials: value.materials?,
                parameters: value.parameters?,
            })
        }
    }
    impl From<super::Completeness> for Completeness {
        fn from(value: super::Completeness) -> Self {
            Self {
                environment: Ok(value.environment),
                materials: Ok(value.materials),
                parameters: Ok(value.parameters),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ConfigSource {
        digest: Result<Option<std::collections::HashMap<String, String>>, String>,
        entry_point: Result<Option<String>, String>,
        uri: Result<Option<String>, String>,
    }
    impl Default for ConfigSource {
        fn default() -> Self {
            Self {
                digest: Ok(Default::default()),
                entry_point: Ok(Default::default()),
                uri: Ok(Default::default()),
            }
        }
    }
    impl ConfigSource {
        pub fn digest<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<std::collections::HashMap<String, String>>>,
            T::Error: std::fmt::Display,
        {
            self
                .digest = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for digest: {}", e)
                });
            self
        }
        pub fn entry_point<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .entry_point = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for entry_point: {}", e)
                });
            self
        }
        pub fn uri<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .uri = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for uri: {}", e));
            self
        }
    }
    impl std::convert::TryFrom<ConfigSource> for super::ConfigSource {
        type Error = String;
        fn try_from(value: ConfigSource) -> Result<Self, String> {
            Ok(Self {
                digest: value.digest?,
                entry_point: value.entry_point?,
                uri: value.uri?,
            })
        }
    }
    impl From<super::ConfigSource> for ConfigSource {
        fn from(value: super::ConfigSource) -> Self {
            Self {
                digest: Ok(value.digest),
                entry_point: Ok(value.entry_point),
                uri: Ok(value.uri),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct InTotoStatementV1ForPredicate {
        predicate: Result<super::Predicate, String>,
        predicate_type: Result<String, String>,
        subject: Result<Vec<super::Subject>, String>,
        type_: Result<String, String>,
    }
    impl Default for InTotoStatementV1ForPredicate {
        fn default() -> Self {
            Self {
                predicate: Err("no value supplied for predicate".to_string()),
                predicate_type: Err("no value supplied for predicate_type".to_string()),
                subject: Err("no value supplied for subject".to_string()),
                type_: Err("no value supplied for type_".to_string()),
            }
        }
    }
    impl InTotoStatementV1ForPredicate {
        pub fn predicate<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<super::Predicate>,
            T::Error: std::fmt::Display,
        {
            self
                .predicate = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for predicate: {}", e)
                });
            self
        }
        pub fn predicate_type<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .predicate_type = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for predicate_type: {}", e)
                });
            self
        }
        pub fn subject<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Subject>>,
            T::Error: std::fmt::Display,
        {
            self
                .subject = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for subject: {}", e)
                });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .type_ = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for type_: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<InTotoStatementV1ForPredicate>
    for super::InTotoStatementV1ForPredicate {
        type Error = String;
        fn try_from(value: InTotoStatementV1ForPredicate) -> Result<Self, String> {
            Ok(Self {
                predicate: value.predicate?,
                predicate_type: value.predicate_type?,
                subject: value.subject?,
                type_: value.type_?,
            })
        }
    }
    impl From<super::InTotoStatementV1ForPredicate> for InTotoStatementV1ForPredicate {
        fn from(value: super::InTotoStatementV1ForPredicate) -> Self {
            Self {
                predicate: Ok(value.predicate),
                predicate_type: Ok(value.predicate_type),
                subject: Ok(value.subject),
                type_: Ok(value.type_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Invocation {
        config_source: Result<Option<super::ConfigSource>, String>,
        environment: Result<Option<serde_json::Map<String, serde_json::Value>>, String>,
        parameters: Result<Option<serde_json::Map<String, serde_json::Value>>, String>,
    }
    impl Default for Invocation {
        fn default() -> Self {
            Self {
                config_source: Ok(Default::default()),
                environment: Ok(Default::default()),
                parameters: Ok(Default::default()),
            }
        }
    }
    impl Invocation {
        pub fn config_source<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ConfigSource>>,
            T::Error: std::fmt::Display,
        {
            self
                .config_source = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for config_source: {}", e)
                });
            self
        }
        pub fn environment<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<serde_json::Map<String, serde_json::Value>>>,
            T::Error: std::fmt::Display,
        {
            self
                .environment = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for environment: {}", e)
                });
            self
        }
        pub fn parameters<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<serde_json::Map<String, serde_json::Value>>>,
            T::Error: std::fmt::Display,
        {
            self
                .parameters = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for parameters: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Invocation> for super::Invocation {
        type Error = String;
        fn try_from(value: Invocation) -> Result<Self, String> {
            Ok(Self {
                config_source: value.config_source?,
                environment: value.environment?,
                parameters: value.parameters?,
            })
        }
    }
    impl From<super::Invocation> for Invocation {
        fn from(value: super::Invocation) -> Self {
            Self {
                config_source: Ok(value.config_source),
                environment: Ok(value.environment),
                parameters: Ok(value.parameters),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Predicate {
        subtype_0: Result<Option<super::SlsaProvenanceV1Predicate>, String>,
        subtype_1: Result<Option<super::SlsaProvenanceV02Predicate>, String>,
        subtype_2: Result<Option<super::Scaiv02Predicate>, String>,
        subtype_3: Result<Option<serde_json::Value>, String>,
    }
    impl Default for Predicate {
        fn default() -> Self {
            Self {
                subtype_0: Ok(Default::default()),
                subtype_1: Ok(Default::default()),
                subtype_2: Ok(Default::default()),
                subtype_3: Ok(Default::default()),
            }
        }
    }
    impl Predicate {
        pub fn subtype_0<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::SlsaProvenanceV1Predicate>>,
            T::Error: std::fmt::Display,
        {
            self
                .subtype_0 = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for subtype_0: {}", e)
                });
            self
        }
        pub fn subtype_1<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::SlsaProvenanceV02Predicate>>,
            T::Error: std::fmt::Display,
        {
            self
                .subtype_1 = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for subtype_1: {}", e)
                });
            self
        }
        pub fn subtype_2<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::Scaiv02Predicate>>,
            T::Error: std::fmt::Display,
        {
            self
                .subtype_2 = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for subtype_2: {}", e)
                });
            self
        }
        pub fn subtype_3<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<serde_json::Value>>,
            T::Error: std::fmt::Display,
        {
            self
                .subtype_3 = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for subtype_3: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Predicate> for super::Predicate {
        type Error = String;
        fn try_from(value: Predicate) -> Result<Self, String> {
            Ok(Self {
                subtype_0: value.subtype_0?,
                subtype_1: value.subtype_1?,
                subtype_2: value.subtype_2?,
                subtype_3: value.subtype_3?,
            })
        }
    }
    impl From<super::Predicate> for Predicate {
        fn from(value: super::Predicate) -> Self {
            Self {
                subtype_0: Ok(value.subtype_0),
                subtype_1: Ok(value.subtype_1),
                subtype_2: Ok(value.subtype_2),
                subtype_3: Ok(value.subtype_3),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ResourceDescriptor {
        annotations: Result<Option<serde_json::Map<String, serde_json::Value>>, String>,
        content: Result<Option<String>, String>,
        digest: Result<Option<std::collections::HashMap<String, String>>, String>,
        download_location: Result<Option<String>, String>,
        media_type: Result<Option<String>, String>,
        name: Result<Option<String>, String>,
        uri: Result<String, String>,
    }
    impl Default for ResourceDescriptor {
        fn default() -> Self {
            Self {
                annotations: Ok(Default::default()),
                content: Ok(Default::default()),
                digest: Ok(Default::default()),
                download_location: Ok(Default::default()),
                media_type: Ok(Default::default()),
                name: Ok(Default::default()),
                uri: Err("no value supplied for uri".to_string()),
            }
        }
    }
    impl ResourceDescriptor {
        pub fn annotations<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<serde_json::Map<String, serde_json::Value>>>,
            T::Error: std::fmt::Display,
        {
            self
                .annotations = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for annotations: {}", e)
                });
            self
        }
        pub fn content<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .content = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for content: {}", e)
                });
            self
        }
        pub fn digest<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<std::collections::HashMap<String, String>>>,
            T::Error: std::fmt::Display,
        {
            self
                .digest = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for digest: {}", e)
                });
            self
        }
        pub fn download_location<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .download_location = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for download_location: {}", e
                    )
                });
            self
        }
        pub fn media_type<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .media_type = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for media_type: {}", e)
                });
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn uri<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .uri = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for uri: {}", e));
            self
        }
    }
    impl std::convert::TryFrom<ResourceDescriptor> for super::ResourceDescriptor {
        type Error = String;
        fn try_from(value: ResourceDescriptor) -> Result<Self, String> {
            Ok(Self {
                annotations: value.annotations?,
                content: value.content?,
                digest: value.digest?,
                download_location: value.download_location?,
                media_type: value.media_type?,
                name: value.name?,
                uri: value.uri?,
            })
        }
    }
    impl From<super::ResourceDescriptor> for ResourceDescriptor {
        fn from(value: super::ResourceDescriptor) -> Self {
            Self {
                annotations: Ok(value.annotations),
                content: Ok(value.content),
                digest: Ok(value.digest),
                download_location: Ok(value.download_location),
                media_type: Ok(value.media_type),
                name: Ok(value.name),
                uri: Ok(value.uri),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ResourceDescriptor2 {
        digest: Result<Option<std::collections::HashMap<String, String>>, String>,
        uri: Result<Option<String>, String>,
    }
    impl Default for ResourceDescriptor2 {
        fn default() -> Self {
            Self {
                digest: Ok(Default::default()),
                uri: Ok(Default::default()),
            }
        }
    }
    impl ResourceDescriptor2 {
        pub fn digest<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<std::collections::HashMap<String, String>>>,
            T::Error: std::fmt::Display,
        {
            self
                .digest = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for digest: {}", e)
                });
            self
        }
        pub fn uri<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .uri = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for uri: {}", e));
            self
        }
    }
    impl std::convert::TryFrom<ResourceDescriptor2> for super::ResourceDescriptor2 {
        type Error = String;
        fn try_from(value: ResourceDescriptor2) -> Result<Self, String> {
            Ok(Self {
                digest: value.digest?,
                uri: value.uri?,
            })
        }
    }
    impl From<super::ResourceDescriptor2> for ResourceDescriptor2 {
        fn from(value: super::ResourceDescriptor2) -> Self {
            Self {
                digest: Ok(value.digest),
                uri: Ok(value.uri),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct RunDetails {
        builder: Result<super::Builder, String>,
        byproducts: Result<Option<Vec<super::ResourceDescriptor>>, String>,
        metadata: Result<Option<super::BuildMetadata>, String>,
    }
    impl Default for RunDetails {
        fn default() -> Self {
            Self {
                builder: Err("no value supplied for builder".to_string()),
                byproducts: Ok(Default::default()),
                metadata: Ok(Default::default()),
            }
        }
    }
    impl RunDetails {
        pub fn builder<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<super::Builder>,
            T::Error: std::fmt::Display,
        {
            self
                .builder = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for builder: {}", e)
                });
            self
        }
        pub fn byproducts<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<Vec<super::ResourceDescriptor>>>,
            T::Error: std::fmt::Display,
        {
            self
                .byproducts = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for byproducts: {}", e)
                });
            self
        }
        pub fn metadata<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::BuildMetadata>>,
            T::Error: std::fmt::Display,
        {
            self
                .metadata = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for metadata: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<RunDetails> for super::RunDetails {
        type Error = String;
        fn try_from(value: RunDetails) -> Result<Self, String> {
            Ok(Self {
                builder: value.builder?,
                byproducts: value.byproducts?,
                metadata: value.metadata?,
            })
        }
    }
    impl From<super::RunDetails> for RunDetails {
        fn from(value: super::RunDetails) -> Self {
            Self {
                builder: Ok(value.builder),
                byproducts: Ok(value.byproducts),
                metadata: Ok(value.metadata),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Scaiv02Predicate {
        attributes: Result<Vec<super::Attribute>, String>,
        producer: Result<Option<super::ResourceDescriptor>, String>,
    }
    impl Default for Scaiv02Predicate {
        fn default() -> Self {
            Self {
                attributes: Err("no value supplied for attributes".to_string()),
                producer: Ok(Default::default()),
            }
        }
    }
    impl Scaiv02Predicate {
        pub fn attributes<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Attribute>>,
            T::Error: std::fmt::Display,
        {
            self
                .attributes = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for attributes: {}", e)
                });
            self
        }
        pub fn producer<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ResourceDescriptor>>,
            T::Error: std::fmt::Display,
        {
            self
                .producer = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for producer: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Scaiv02Predicate> for super::Scaiv02Predicate {
        type Error = String;
        fn try_from(value: Scaiv02Predicate) -> Result<Self, String> {
            Ok(Self {
                attributes: value.attributes?,
                producer: value.producer?,
            })
        }
    }
    impl From<super::Scaiv02Predicate> for Scaiv02Predicate {
        fn from(value: super::Scaiv02Predicate) -> Self {
            Self {
                attributes: Ok(value.attributes),
                producer: Ok(value.producer),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct SlsaProvenanceV02Predicate {
        build_config: Result<Option<serde_json::Map<String, serde_json::Value>>, String>,
        build_type: Result<String, String>,
        builder: Result<super::Builder2, String>,
        invocation: Result<Option<super::Invocation>, String>,
        materials: Result<Option<Vec<super::ResourceDescriptor2>>, String>,
        metadata: Result<Option<super::BuildMetadata2>, String>,
    }
    impl Default for SlsaProvenanceV02Predicate {
        fn default() -> Self {
            Self {
                build_config: Ok(Default::default()),
                build_type: Err("no value supplied for build_type".to_string()),
                builder: Err("no value supplied for builder".to_string()),
                invocation: Ok(Default::default()),
                materials: Ok(Default::default()),
                metadata: Ok(Default::default()),
            }
        }
    }
    impl SlsaProvenanceV02Predicate {
        pub fn build_config<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<serde_json::Map<String, serde_json::Value>>>,
            T::Error: std::fmt::Display,
        {
            self
                .build_config = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for build_config: {}", e)
                });
            self
        }
        pub fn build_type<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .build_type = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for build_type: {}", e)
                });
            self
        }
        pub fn builder<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<super::Builder2>,
            T::Error: std::fmt::Display,
        {
            self
                .builder = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for builder: {}", e)
                });
            self
        }
        pub fn invocation<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::Invocation>>,
            T::Error: std::fmt::Display,
        {
            self
                .invocation = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for invocation: {}", e)
                });
            self
        }
        pub fn materials<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<Vec<super::ResourceDescriptor2>>>,
            T::Error: std::fmt::Display,
        {
            self
                .materials = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for materials: {}", e)
                });
            self
        }
        pub fn metadata<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::BuildMetadata2>>,
            T::Error: std::fmt::Display,
        {
            self
                .metadata = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for metadata: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<SlsaProvenanceV02Predicate>
    for super::SlsaProvenanceV02Predicate {
        type Error = String;
        fn try_from(value: SlsaProvenanceV02Predicate) -> Result<Self, String> {
            Ok(Self {
                build_config: value.build_config?,
                build_type: value.build_type?,
                builder: value.builder?,
                invocation: value.invocation?,
                materials: value.materials?,
                metadata: value.metadata?,
            })
        }
    }
    impl From<super::SlsaProvenanceV02Predicate> for SlsaProvenanceV02Predicate {
        fn from(value: super::SlsaProvenanceV02Predicate) -> Self {
            Self {
                build_config: Ok(value.build_config),
                build_type: Ok(value.build_type),
                builder: Ok(value.builder),
                invocation: Ok(value.invocation),
                materials: Ok(value.materials),
                metadata: Ok(value.metadata),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct SlsaProvenanceV1Predicate {
        build_definition: Result<super::BuildDefinition, String>,
        run_details: Result<super::RunDetails, String>,
    }
    impl Default for SlsaProvenanceV1Predicate {
        fn default() -> Self {
            Self {
                build_definition: Err(
                    "no value supplied for build_definition".to_string(),
                ),
                run_details: Err("no value supplied for run_details".to_string()),
            }
        }
    }
    impl SlsaProvenanceV1Predicate {
        pub fn build_definition<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<super::BuildDefinition>,
            T::Error: std::fmt::Display,
        {
            self
                .build_definition = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for build_definition: {}", e
                    )
                });
            self
        }
        pub fn run_details<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<super::RunDetails>,
            T::Error: std::fmt::Display,
        {
            self
                .run_details = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for run_details: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<SlsaProvenanceV1Predicate>
    for super::SlsaProvenanceV1Predicate {
        type Error = String;
        fn try_from(value: SlsaProvenanceV1Predicate) -> Result<Self, String> {
            Ok(Self {
                build_definition: value.build_definition?,
                run_details: value.run_details?,
            })
        }
    }
    impl From<super::SlsaProvenanceV1Predicate> for SlsaProvenanceV1Predicate {
        fn from(value: super::SlsaProvenanceV1Predicate) -> Self {
            Self {
                build_definition: Ok(value.build_definition),
                run_details: Ok(value.run_details),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Subject {
        digest: Result<super::DigestSet, String>,
        name: Result<String, String>,
    }
    impl Default for Subject {
        fn default() -> Self {
            Self {
                digest: Err("no value supplied for digest".to_string()),
                name: Err("no value supplied for name".to_string()),
            }
        }
    }
    impl Subject {
        pub fn digest<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<super::DigestSet>,
            T::Error: std::fmt::Display,
        {
            self
                .digest = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for digest: {}", e)
                });
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
    }
    impl std::convert::TryFrom<Subject> for super::Subject {
        type Error = String;
        fn try_from(value: Subject) -> Result<Self, String> {
            Ok(Self {
                digest: value.digest?,
                name: value.name?,
            })
        }
    }
    impl From<super::Subject> for Subject {
        fn from(value: super::Subject) -> Self {
            Self {
                digest: Ok(value.digest),
                name: Ok(value.name),
            }
        }
    }
}

