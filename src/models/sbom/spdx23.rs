//! This file is generated by typify through Spector. Do not edit it directly.
//! Exceptions to this rule are for cases where typify doesn't genrate the correct code.
#![allow(clippy::all)]
#![allow(warnings)]
use serde::{Deserialize, Serialize};
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct Spdx23 {
    ///Provide additional information about an SpdxElement.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub annotations: Vec<Spdx23AnnotationsItem>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    #[serde(rename = "creationInfo")]
    pub creation_info: Spdx23CreationInfo,
    ///License expression for dataLicense. See SPDX Annex D for the license expression syntax.  Compliance with the SPDX specification includes populating the SPDX fields therein with data related to such fields ("SPDX-Metadata"). The SPDX specification contains numerous fields where an SPDX document creator may provide relevant explanatory text in SPDX-Metadata. Without opining on the lawfulness of "database rights" (in jurisdictions where applicable), such explanatory text is copyrightable subject matter in most Berne Convention countries. By using the SPDX specification, or any portion hereof, you hereby agree that any copyright rights (as determined by your jurisdiction) in any SPDX-Metadata, including without limitation explanatory text, shall be subject to the terms of the Creative Commons CC0 1.0 Universal license. For SPDX-Metadata not containing any copyright rights, you hereby agree and acknowledge that the SPDX-Metadata is provided to you "as-is" and without any representations or warranties of any kind concerning the SPDX-Metadata, express, implied, statutory or otherwise, including without limitation warranties of title, merchantability, fitness for a particular purpose, non-infringement, or the absence of latent or other defects, accuracy, or the presence or absence of errors, whether or not discoverable, all to the greatest extent permissible under applicable law.
    #[serde(rename = "dataLicense")]
    pub data_license: String,
    ///DEPRECATED: use relationships instead of this field. Packages, files and/or Snippets described by this SPDX document
    #[serde(
        rename = "documentDescribes",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub document_describes: Vec<String>,
    ///The URI provides an unambiguous mechanism for other SPDX documents to reference SPDX elements within this SPDX document.
    #[serde(rename = "documentNamespace")]
    pub document_namespace: String,
    ///Identify any external SPDX documents referenced within this SPDX document.
    #[serde(
        rename = "externalDocumentRefs",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub external_document_refs: Vec<Spdx23ExternalDocumentRefsItem>,
    ///Files referenced in the SPDX document
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub files: Vec<Spdx23FilesItem>,
    ///Indicates that a particular ExtractedLicensingInfo was defined in the subject SpdxDocument.
    #[serde(
        rename = "hasExtractedLicensingInfos",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub has_extracted_licensing_infos: Vec<Spdx23HasExtractedLicensingInfosItem>,
    ///Identify name of this SpdxElement.
    pub name: String,
    ///Packages referenced in the SPDX document
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub packages: Vec<Spdx23PackagesItem>,
    ///Relationships referenced in the SPDX document
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub relationships: Vec<Spdx23RelationshipsItem>,
    ///Reviewed
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub revieweds: Vec<Spdx23ReviewedsItem>,
    ///Snippets referenced in the SPDX document
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub snippets: Vec<Spdx23SnippetsItem>,
    ///Provide a reference number that can be used to understand how to parse and interpret the rest of the file. It will enable both future changes to the specification and to support backward compatibility. The version number consists of a major and minor version indicator. The major field will be incremented when incompatible changes between versions are made (one or more sections are created, modified or deleted). The minor field will be incremented when backwards compatible changes are made.
    #[serde(rename = "spdxVersion")]
    pub spdx_version: String,
    ///Uniquely identify any element in an SPDX document which may be referenced by other elements.
    #[serde(rename = "SPDXID")]
    pub spdxid: String,
}
impl From<&Spdx23> for Spdx23 {
    fn from(value: &Spdx23) -> Self {
        value.clone()
    }
}
impl Spdx23 {
    pub fn builder() -> builder::Spdx23 {
        builder::Spdx23::default()
    }
}
///An Annotation is a comment on an SpdxItem by an agent.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct Spdx23AnnotationsItem {
    ///Identify when the comment was made. This is to be specified according to the combined date and time in the UTC format, as specified in the ISO 8601 standard.
    #[serde(rename = "annotationDate")]
    pub annotation_date: String,
    ///Type of the annotation.
    #[serde(rename = "annotationType")]
    pub annotation_type: Spdx23AnnotationsItemAnnotationType,
    ///This field identifies the person, organization, or tool that has commented on a file, package, snippet, or the entire document.
    pub annotator: String,
    pub comment: String,
}
impl From<&Spdx23AnnotationsItem> for Spdx23AnnotationsItem {
    fn from(value: &Spdx23AnnotationsItem) -> Self {
        value.clone()
    }
}
impl Spdx23AnnotationsItem {
    pub fn builder() -> builder::Spdx23AnnotationsItem {
        builder::Spdx23AnnotationsItem::default()
    }
}
///Type of the annotation.
#[derive(
    Clone,
    Copy,
    Debug,
    Deserialize,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
    Serialize,
    schemars::JsonSchema
)]
pub enum Spdx23AnnotationsItemAnnotationType {
    #[serde(rename = "OTHER")]
    Other,
    #[serde(rename = "REVIEW")]
    Review,
}
impl From<&Spdx23AnnotationsItemAnnotationType> for Spdx23AnnotationsItemAnnotationType {
    fn from(value: &Spdx23AnnotationsItemAnnotationType) -> Self {
        value.clone()
    }
}
impl ToString for Spdx23AnnotationsItemAnnotationType {
    fn to_string(&self) -> String {
        match *self {
            Self::Other => "OTHER".to_string(),
            Self::Review => "REVIEW".to_string(),
        }
    }
}
impl std::str::FromStr for Spdx23AnnotationsItemAnnotationType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "OTHER" => Ok(Self::Other),
            "REVIEW" => Ok(Self::Review),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for Spdx23AnnotationsItemAnnotationType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for Spdx23AnnotationsItemAnnotationType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for Spdx23AnnotationsItemAnnotationType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
///One instance is required for each SPDX file produced. It provides the necessary information for forward and backward compatibility for processing tools.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct Spdx23CreationInfo {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    ///Identify when the SPDX document was originally created. The date is to be specified according to combined date and time in UTC format as specified in ISO 8601 standard.
    pub created: String,
    ///Identify who (or what, in the case of a tool) created the SPDX document. If the SPDX document was created by an individual, indicate the person's name. If the SPDX document was created on behalf of a company or organization, indicate the entity name. If the SPDX document was created using a software tool, indicate the name and version for that tool. If multiple participants or tools were involved, use multiple instances of this field. Person name or organization name may be designated as “anonymous” if appropriate.
    pub creators: Vec<String>,
    ///An optional field for creators of the SPDX file to provide the version of the SPDX License List used when the SPDX file was created.
    #[serde(
        rename = "licenseListVersion",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub license_list_version: Option<String>,
}
impl From<&Spdx23CreationInfo> for Spdx23CreationInfo {
    fn from(value: &Spdx23CreationInfo) -> Self {
        value.clone()
    }
}
impl Spdx23CreationInfo {
    pub fn builder() -> builder::Spdx23CreationInfo {
        builder::Spdx23CreationInfo::default()
    }
}
///Information about an external SPDX document reference including the checksum. This allows for verification of the external references.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct Spdx23ExternalDocumentRefsItem {
    pub checksum: Spdx23ExternalDocumentRefsItemChecksum,
    ///externalDocumentId is a string containing letters, numbers, ., - and/or + which uniquely identifies an external document within this document.
    #[serde(rename = "externalDocumentId")]
    pub external_document_id: String,
    ///SPDX ID for SpdxDocument.  A property containing an SPDX document.
    #[serde(rename = "spdxDocument")]
    pub spdx_document: String,
}
impl From<&Spdx23ExternalDocumentRefsItem> for Spdx23ExternalDocumentRefsItem {
    fn from(value: &Spdx23ExternalDocumentRefsItem) -> Self {
        value.clone()
    }
}
impl Spdx23ExternalDocumentRefsItem {
    pub fn builder() -> builder::Spdx23ExternalDocumentRefsItem {
        builder::Spdx23ExternalDocumentRefsItem::default()
    }
}
///A Checksum is value that allows the contents of a file to be authenticated. Even small changes to the content of the file will change its checksum. This class allows the results of a variety of checksum and cryptographic message digest algorithms to be represented.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct Spdx23ExternalDocumentRefsItemChecksum {
    ///Identifies the algorithm used to produce the subject Checksum. Currently, SHA-1 is the only supported algorithm. It is anticipated that other algorithms will be supported at a later time.
    pub algorithm: Spdx23ExternalDocumentRefsItemChecksumAlgorithm,
    ///The checksumValue property provides a lower case hexidecimal encoded digest value produced using a specific algorithm.
    #[serde(rename = "checksumValue")]
    pub checksum_value: String,
}
impl From<&Spdx23ExternalDocumentRefsItemChecksum>
for Spdx23ExternalDocumentRefsItemChecksum {
    fn from(value: &Spdx23ExternalDocumentRefsItemChecksum) -> Self {
        value.clone()
    }
}
impl Spdx23ExternalDocumentRefsItemChecksum {
    pub fn builder() -> builder::Spdx23ExternalDocumentRefsItemChecksum {
        builder::Spdx23ExternalDocumentRefsItemChecksum::default()
    }
}
///Identifies the algorithm used to produce the subject Checksum. Currently, SHA-1 is the only supported algorithm. It is anticipated that other algorithms will be supported at a later time.
#[derive(
    Clone,
    Copy,
    Debug,
    Deserialize,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
    Serialize,
    schemars::JsonSchema
)]
pub enum Spdx23ExternalDocumentRefsItemChecksumAlgorithm {
    #[serde(rename = "SHA1")]
    Sha1,
    #[serde(rename = "BLAKE3")]
    Blake3,
    #[serde(rename = "SHA3-384")]
    Sha3384,
    #[serde(rename = "SHA256")]
    Sha256,
    #[serde(rename = "SHA384")]
    Sha384,
    #[serde(rename = "BLAKE2b-512")]
    Blake2b512,
    #[serde(rename = "BLAKE2b-256")]
    Blake2b256,
    #[serde(rename = "SHA3-512")]
    Sha3512,
    #[serde(rename = "MD2")]
    Md2,
    #[serde(rename = "ADLER32")]
    Adler32,
    #[serde(rename = "MD4")]
    Md4,
    #[serde(rename = "SHA3-256")]
    Sha3256,
    #[serde(rename = "BLAKE2b-384")]
    Blake2b384,
    #[serde(rename = "SHA512")]
    Sha512,
    #[serde(rename = "MD6")]
    Md6,
    #[serde(rename = "MD5")]
    Md5,
    #[serde(rename = "SHA224")]
    Sha224,
}
impl From<&Spdx23ExternalDocumentRefsItemChecksumAlgorithm>
for Spdx23ExternalDocumentRefsItemChecksumAlgorithm {
    fn from(value: &Spdx23ExternalDocumentRefsItemChecksumAlgorithm) -> Self {
        value.clone()
    }
}
impl ToString for Spdx23ExternalDocumentRefsItemChecksumAlgorithm {
    fn to_string(&self) -> String {
        match *self {
            Self::Sha1 => "SHA1".to_string(),
            Self::Blake3 => "BLAKE3".to_string(),
            Self::Sha3384 => "SHA3-384".to_string(),
            Self::Sha256 => "SHA256".to_string(),
            Self::Sha384 => "SHA384".to_string(),
            Self::Blake2b512 => "BLAKE2b-512".to_string(),
            Self::Blake2b256 => "BLAKE2b-256".to_string(),
            Self::Sha3512 => "SHA3-512".to_string(),
            Self::Md2 => "MD2".to_string(),
            Self::Adler32 => "ADLER32".to_string(),
            Self::Md4 => "MD4".to_string(),
            Self::Sha3256 => "SHA3-256".to_string(),
            Self::Blake2b384 => "BLAKE2b-384".to_string(),
            Self::Sha512 => "SHA512".to_string(),
            Self::Md6 => "MD6".to_string(),
            Self::Md5 => "MD5".to_string(),
            Self::Sha224 => "SHA224".to_string(),
        }
    }
}
impl std::str::FromStr for Spdx23ExternalDocumentRefsItemChecksumAlgorithm {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "SHA1" => Ok(Self::Sha1),
            "BLAKE3" => Ok(Self::Blake3),
            "SHA3-384" => Ok(Self::Sha3384),
            "SHA256" => Ok(Self::Sha256),
            "SHA384" => Ok(Self::Sha384),
            "BLAKE2b-512" => Ok(Self::Blake2b512),
            "BLAKE2b-256" => Ok(Self::Blake2b256),
            "SHA3-512" => Ok(Self::Sha3512),
            "MD2" => Ok(Self::Md2),
            "ADLER32" => Ok(Self::Adler32),
            "MD4" => Ok(Self::Md4),
            "SHA3-256" => Ok(Self::Sha3256),
            "BLAKE2b-384" => Ok(Self::Blake2b384),
            "SHA512" => Ok(Self::Sha512),
            "MD6" => Ok(Self::Md6),
            "MD5" => Ok(Self::Md5),
            "SHA224" => Ok(Self::Sha224),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for Spdx23ExternalDocumentRefsItemChecksumAlgorithm {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for Spdx23ExternalDocumentRefsItemChecksumAlgorithm {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for Spdx23ExternalDocumentRefsItemChecksumAlgorithm {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct Spdx23FilesItem {
    ///Provide additional information about an SpdxElement.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub annotations: Vec<Spdx23FilesItemAnnotationsItem>,
    ///Indicates the project in which the SpdxElement originated. Tools must preserve doap:homepage and doap:name properties and the URI (if one is known) of doap:Project resources that are values of this property. All other properties of doap:Projects are not directly supported by SPDX and may be dropped when translating to or from some SPDX formats.
    #[serde(rename = "artifactOfs", default, skip_serializing_if = "Vec::is_empty")]
    pub artifact_ofs: Vec<std::collections::HashMap<String, serde_json::Value>>,
    ///This field provides a place for the SPDX data creator to record acknowledgements that may be required to be communicated in some contexts. This is not meant to include the actual complete license text (see licenseConculded and licenseDeclared), and may or may not include copyright notices (see also copyrightText). The SPDX data creator may use this field to record other acknowledgements, such as particular clauses from license texts, which may be necessary or desirable to reproduce.
    #[serde(rename = "attributionTexts", default, skip_serializing_if = "Vec::is_empty")]
    pub attribution_texts: Vec<String>,
    ///The checksum property provides a mechanism that can be used to verify that the contents of a File or Package have not changed.
    pub checksums: Vec<Spdx23FilesItemChecksumsItem>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    /**The text of copyright declarations recited in the package, file or snippet.

If the copyrightText field is not present, it implies an equivalent meaning to NOASSERTION.*/
    #[serde(rename = "copyrightText", default, skip_serializing_if = "Option::is_none")]
    pub copyright_text: Option<String>,
    ///This field provides a place for the SPDX file creator to record file contributors. Contributors could include names of copyright holders and/or authors who may not be copyright holders yet contributed to the file content.
    #[serde(rename = "fileContributors", default, skip_serializing_if = "Vec::is_empty")]
    pub file_contributors: Vec<String>,
    ///This field is deprecated since SPDX 2.0 in favor of using Section 7 which provides more granularity about relationships.
    #[serde(rename = "fileDependencies", default, skip_serializing_if = "Vec::is_empty")]
    pub file_dependencies: Vec<String>,
    ///The name of the file relative to the root of the package.
    #[serde(rename = "fileName")]
    pub file_name: String,
    ///The type of the file.
    #[serde(rename = "fileTypes", default, skip_serializing_if = "Vec::is_empty")]
    pub file_types: Vec<Spdx23FilesItemFileTypesItem>,
    ///The licenseComments property allows the preparer of the SPDX document to describe why the licensing in spdx:licenseConcluded was chosen.
    #[serde(
        rename = "licenseComments",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub license_comments: Option<String>,
    /**License expression for licenseConcluded. See SPDX Annex D for the license expression syntax.  The licensing that the preparer of this SPDX document has concluded, based on the evidence, actually applies to the SPDX Item.

If the licenseConcluded field is not present for an SPDX Item, it implies an equivalent meaning to NOASSERTION.*/
    #[serde(
        rename = "licenseConcluded",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub license_concluded: Option<String>,
    /**Licensing information that was discovered directly in the subject file. This is also considered a declared license for the file.

If the licenseInfoInFile field is not present for a file, it implies an equivalent meaning to NOASSERTION.*/
    #[serde(
        rename = "licenseInfoInFiles",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub license_info_in_files: Vec<String>,
    ///This field provides a place for the SPDX file creator to record potential legal notices found in the file. This may or may not include copyright statements.
    #[serde(rename = "noticeText", default, skip_serializing_if = "Option::is_none")]
    pub notice_text: Option<String>,
    ///Uniquely identify any element in an SPDX document which may be referenced by other elements.
    #[serde(rename = "SPDXID")]
    pub spdxid: String,
}
impl From<&Spdx23FilesItem> for Spdx23FilesItem {
    fn from(value: &Spdx23FilesItem) -> Self {
        value.clone()
    }
}
impl Spdx23FilesItem {
    pub fn builder() -> builder::Spdx23FilesItem {
        builder::Spdx23FilesItem::default()
    }
}
///An Annotation is a comment on an SpdxItem by an agent.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct Spdx23FilesItemAnnotationsItem {
    ///Identify when the comment was made. This is to be specified according to the combined date and time in the UTC format, as specified in the ISO 8601 standard.
    #[serde(rename = "annotationDate")]
    pub annotation_date: String,
    ///Type of the annotation.
    #[serde(rename = "annotationType")]
    pub annotation_type: Spdx23FilesItemAnnotationsItemAnnotationType,
    ///This field identifies the person, organization, or tool that has commented on a file, package, snippet, or the entire document.
    pub annotator: String,
    pub comment: String,
}
impl From<&Spdx23FilesItemAnnotationsItem> for Spdx23FilesItemAnnotationsItem {
    fn from(value: &Spdx23FilesItemAnnotationsItem) -> Self {
        value.clone()
    }
}
impl Spdx23FilesItemAnnotationsItem {
    pub fn builder() -> builder::Spdx23FilesItemAnnotationsItem {
        builder::Spdx23FilesItemAnnotationsItem::default()
    }
}
///Type of the annotation.
#[derive(
    Clone,
    Copy,
    Debug,
    Deserialize,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
    Serialize,
    schemars::JsonSchema
)]
pub enum Spdx23FilesItemAnnotationsItemAnnotationType {
    #[serde(rename = "OTHER")]
    Other,
    #[serde(rename = "REVIEW")]
    Review,
}
impl From<&Spdx23FilesItemAnnotationsItemAnnotationType>
for Spdx23FilesItemAnnotationsItemAnnotationType {
    fn from(value: &Spdx23FilesItemAnnotationsItemAnnotationType) -> Self {
        value.clone()
    }
}
impl ToString for Spdx23FilesItemAnnotationsItemAnnotationType {
    fn to_string(&self) -> String {
        match *self {
            Self::Other => "OTHER".to_string(),
            Self::Review => "REVIEW".to_string(),
        }
    }
}
impl std::str::FromStr for Spdx23FilesItemAnnotationsItemAnnotationType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "OTHER" => Ok(Self::Other),
            "REVIEW" => Ok(Self::Review),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for Spdx23FilesItemAnnotationsItemAnnotationType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for Spdx23FilesItemAnnotationsItemAnnotationType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for Spdx23FilesItemAnnotationsItemAnnotationType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
///A Checksum is value that allows the contents of a file to be authenticated. Even small changes to the content of the file will change its checksum. This class allows the results of a variety of checksum and cryptographic message digest algorithms to be represented.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct Spdx23FilesItemChecksumsItem {
    ///Identifies the algorithm used to produce the subject Checksum. Currently, SHA-1 is the only supported algorithm. It is anticipated that other algorithms will be supported at a later time.
    pub algorithm: Spdx23FilesItemChecksumsItemAlgorithm,
    ///The checksumValue property provides a lower case hexidecimal encoded digest value produced using a specific algorithm.
    #[serde(rename = "checksumValue")]
    pub checksum_value: String,
}
impl From<&Spdx23FilesItemChecksumsItem> for Spdx23FilesItemChecksumsItem {
    fn from(value: &Spdx23FilesItemChecksumsItem) -> Self {
        value.clone()
    }
}
impl Spdx23FilesItemChecksumsItem {
    pub fn builder() -> builder::Spdx23FilesItemChecksumsItem {
        builder::Spdx23FilesItemChecksumsItem::default()
    }
}
///Identifies the algorithm used to produce the subject Checksum. Currently, SHA-1 is the only supported algorithm. It is anticipated that other algorithms will be supported at a later time.
#[derive(
    Clone,
    Copy,
    Debug,
    Deserialize,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
    Serialize,
    schemars::JsonSchema
)]
pub enum Spdx23FilesItemChecksumsItemAlgorithm {
    #[serde(rename = "SHA1")]
    Sha1,
    #[serde(rename = "BLAKE3")]
    Blake3,
    #[serde(rename = "SHA3-384")]
    Sha3384,
    #[serde(rename = "SHA256")]
    Sha256,
    #[serde(rename = "SHA384")]
    Sha384,
    #[serde(rename = "BLAKE2b-512")]
    Blake2b512,
    #[serde(rename = "BLAKE2b-256")]
    Blake2b256,
    #[serde(rename = "SHA3-512")]
    Sha3512,
    #[serde(rename = "MD2")]
    Md2,
    #[serde(rename = "ADLER32")]
    Adler32,
    #[serde(rename = "MD4")]
    Md4,
    #[serde(rename = "SHA3-256")]
    Sha3256,
    #[serde(rename = "BLAKE2b-384")]
    Blake2b384,
    #[serde(rename = "SHA512")]
    Sha512,
    #[serde(rename = "MD6")]
    Md6,
    #[serde(rename = "MD5")]
    Md5,
    #[serde(rename = "SHA224")]
    Sha224,
}
impl From<&Spdx23FilesItemChecksumsItemAlgorithm>
for Spdx23FilesItemChecksumsItemAlgorithm {
    fn from(value: &Spdx23FilesItemChecksumsItemAlgorithm) -> Self {
        value.clone()
    }
}
impl ToString for Spdx23FilesItemChecksumsItemAlgorithm {
    fn to_string(&self) -> String {
        match *self {
            Self::Sha1 => "SHA1".to_string(),
            Self::Blake3 => "BLAKE3".to_string(),
            Self::Sha3384 => "SHA3-384".to_string(),
            Self::Sha256 => "SHA256".to_string(),
            Self::Sha384 => "SHA384".to_string(),
            Self::Blake2b512 => "BLAKE2b-512".to_string(),
            Self::Blake2b256 => "BLAKE2b-256".to_string(),
            Self::Sha3512 => "SHA3-512".to_string(),
            Self::Md2 => "MD2".to_string(),
            Self::Adler32 => "ADLER32".to_string(),
            Self::Md4 => "MD4".to_string(),
            Self::Sha3256 => "SHA3-256".to_string(),
            Self::Blake2b384 => "BLAKE2b-384".to_string(),
            Self::Sha512 => "SHA512".to_string(),
            Self::Md6 => "MD6".to_string(),
            Self::Md5 => "MD5".to_string(),
            Self::Sha224 => "SHA224".to_string(),
        }
    }
}
impl std::str::FromStr for Spdx23FilesItemChecksumsItemAlgorithm {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "SHA1" => Ok(Self::Sha1),
            "BLAKE3" => Ok(Self::Blake3),
            "SHA3-384" => Ok(Self::Sha3384),
            "SHA256" => Ok(Self::Sha256),
            "SHA384" => Ok(Self::Sha384),
            "BLAKE2b-512" => Ok(Self::Blake2b512),
            "BLAKE2b-256" => Ok(Self::Blake2b256),
            "SHA3-512" => Ok(Self::Sha3512),
            "MD2" => Ok(Self::Md2),
            "ADLER32" => Ok(Self::Adler32),
            "MD4" => Ok(Self::Md4),
            "SHA3-256" => Ok(Self::Sha3256),
            "BLAKE2b-384" => Ok(Self::Blake2b384),
            "SHA512" => Ok(Self::Sha512),
            "MD6" => Ok(Self::Md6),
            "MD5" => Ok(Self::Md5),
            "SHA224" => Ok(Self::Sha224),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for Spdx23FilesItemChecksumsItemAlgorithm {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for Spdx23FilesItemChecksumsItemAlgorithm {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for Spdx23FilesItemChecksumsItemAlgorithm {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
///The type of the file.
#[derive(
    Clone,
    Copy,
    Debug,
    Deserialize,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
    Serialize,
    schemars::JsonSchema
)]
pub enum Spdx23FilesItemFileTypesItem {
    #[serde(rename = "OTHER")]
    Other,
    #[serde(rename = "DOCUMENTATION")]
    Documentation,
    #[serde(rename = "IMAGE")]
    Image,
    #[serde(rename = "VIDEO")]
    Video,
    #[serde(rename = "ARCHIVE")]
    Archive,
    #[serde(rename = "SPDX")]
    Spdx,
    #[serde(rename = "APPLICATION")]
    Application,
    #[serde(rename = "SOURCE")]
    Source,
    #[serde(rename = "BINARY")]
    Binary,
    #[serde(rename = "TEXT")]
    Text,
    #[serde(rename = "AUDIO")]
    Audio,
}
impl From<&Spdx23FilesItemFileTypesItem> for Spdx23FilesItemFileTypesItem {
    fn from(value: &Spdx23FilesItemFileTypesItem) -> Self {
        value.clone()
    }
}
impl ToString for Spdx23FilesItemFileTypesItem {
    fn to_string(&self) -> String {
        match *self {
            Self::Other => "OTHER".to_string(),
            Self::Documentation => "DOCUMENTATION".to_string(),
            Self::Image => "IMAGE".to_string(),
            Self::Video => "VIDEO".to_string(),
            Self::Archive => "ARCHIVE".to_string(),
            Self::Spdx => "SPDX".to_string(),
            Self::Application => "APPLICATION".to_string(),
            Self::Source => "SOURCE".to_string(),
            Self::Binary => "BINARY".to_string(),
            Self::Text => "TEXT".to_string(),
            Self::Audio => "AUDIO".to_string(),
        }
    }
}
impl std::str::FromStr for Spdx23FilesItemFileTypesItem {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "OTHER" => Ok(Self::Other),
            "DOCUMENTATION" => Ok(Self::Documentation),
            "IMAGE" => Ok(Self::Image),
            "VIDEO" => Ok(Self::Video),
            "ARCHIVE" => Ok(Self::Archive),
            "SPDX" => Ok(Self::Spdx),
            "APPLICATION" => Ok(Self::Application),
            "SOURCE" => Ok(Self::Source),
            "BINARY" => Ok(Self::Binary),
            "TEXT" => Ok(Self::Text),
            "AUDIO" => Ok(Self::Audio),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for Spdx23FilesItemFileTypesItem {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for Spdx23FilesItemFileTypesItem {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for Spdx23FilesItemFileTypesItem {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
///An ExtractedLicensingInfo represents a license or licensing notice that was found in a package, file or snippet. Any license text that is recognized as a license may be represented as a License rather than an ExtractedLicensingInfo.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct Spdx23HasExtractedLicensingInfosItem {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    ///Cross Reference Detail for a license SeeAlso URL
    #[serde(rename = "crossRefs", default, skip_serializing_if = "Vec::is_empty")]
    pub cross_refs: Vec<Spdx23HasExtractedLicensingInfosItemCrossRefsItem>,
    ///Provide a copy of the actual text of the license reference extracted from the package, file or snippet that is associated with the License Identifier to aid in future analysis.
    #[serde(rename = "extractedText")]
    pub extracted_text: String,
    ///A human readable short form license identifier for a license. The license ID is either on the standard license list or the form "LicenseRef-[idString]" where [idString] is a unique string containing letters, numbers, "." or "-".  When used within a license expression, the license ID can optionally include a reference to an external document in the form "DocumentRef-[docrefIdString]:LicenseRef-[idString]" where docRefIdString is an ID for an external document reference.
    #[serde(rename = "licenseId")]
    pub license_id: String,
    ///Identify name of this SpdxElement.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "seeAlsos", default, skip_serializing_if = "Vec::is_empty")]
    pub see_alsos: Vec<String>,
}
impl From<&Spdx23HasExtractedLicensingInfosItem>
for Spdx23HasExtractedLicensingInfosItem {
    fn from(value: &Spdx23HasExtractedLicensingInfosItem) -> Self {
        value.clone()
    }
}
impl Spdx23HasExtractedLicensingInfosItem {
    pub fn builder() -> builder::Spdx23HasExtractedLicensingInfosItem {
        builder::Spdx23HasExtractedLicensingInfosItem::default()
    }
}
///Cross reference details for the a URL reference
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct Spdx23HasExtractedLicensingInfosItemCrossRefsItem {
    ///Indicate a URL is still a live accessible location on the public internet
    #[serde(rename = "isLive", default, skip_serializing_if = "Option::is_none")]
    pub is_live: Option<bool>,
    ///True if the URL is a valid well formed URL
    #[serde(rename = "isValid", default, skip_serializing_if = "Option::is_none")]
    pub is_valid: Option<bool>,
    ///True if the License SeeAlso URL points to a Wayback archive
    #[serde(rename = "isWayBackLink", default, skip_serializing_if = "Option::is_none")]
    pub is_way_back_link: Option<bool>,
    ///Status of a License List SeeAlso URL reference if it refers to a website that matches the license text.
    #[serde(rename = "match", default, skip_serializing_if = "Option::is_none")]
    pub match_: Option<String>,
    ///The ordinal order of this element within a list
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub order: Option<i64>,
    ///Timestamp
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<String>,
    ///URL Reference
    pub url: String,
}
impl From<&Spdx23HasExtractedLicensingInfosItemCrossRefsItem>
for Spdx23HasExtractedLicensingInfosItemCrossRefsItem {
    fn from(value: &Spdx23HasExtractedLicensingInfosItemCrossRefsItem) -> Self {
        value.clone()
    }
}
impl Spdx23HasExtractedLicensingInfosItemCrossRefsItem {
    pub fn builder() -> builder::Spdx23HasExtractedLicensingInfosItemCrossRefsItem {
        builder::Spdx23HasExtractedLicensingInfosItemCrossRefsItem::default()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct Spdx23PackagesItem {
    ///Provide additional information about an SpdxElement.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub annotations: Vec<Spdx23PackagesItemAnnotationsItem>,
    ///This field provides a place for the SPDX data creator to record acknowledgements that may be required to be communicated in some contexts. This is not meant to include the actual complete license text (see licenseConculded and licenseDeclared), and may or may not include copyright notices (see also copyrightText). The SPDX data creator may use this field to record other acknowledgements, such as particular clauses from license texts, which may be necessary or desirable to reproduce.
    #[serde(rename = "attributionTexts", default, skip_serializing_if = "Vec::is_empty")]
    pub attribution_texts: Vec<String>,
    ///This field provides a place for recording the actual date the package was built.
    #[serde(rename = "builtDate", default, skip_serializing_if = "Option::is_none")]
    pub built_date: Option<String>,
    ///The checksum property provides a mechanism that can be used to verify that the contents of a File or Package have not changed.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub checksums: Vec<Spdx23PackagesItemChecksumsItem>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    /**The text of copyright declarations recited in the package, file or snippet.

If the copyrightText field is not present, it implies an equivalent meaning to NOASSERTION.*/
    #[serde(rename = "copyrightText", default, skip_serializing_if = "Option::is_none")]
    pub copyright_text: Option<String>,
    ///Provides a detailed description of the package.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    ///The URI at which this package is available for download. Private (i.e., not publicly reachable) URIs are acceptable as values of this property. The values http://spdx.org/rdf/terms#none and http://spdx.org/rdf/terms#noassertion may be used to specify that the package is not downloadable or that no attempt was made to determine its download location, respectively.
    #[serde(rename = "downloadLocation")]
    pub download_location: String,
    ///An External Reference allows a Package to reference an external source of additional information, metadata, enumerations, asset identifiers, or downloadable content believed to be relevant to the Package.
    #[serde(rename = "externalRefs", default, skip_serializing_if = "Vec::is_empty")]
    pub external_refs: Vec<Spdx23PackagesItemExternalRefsItem>,
    ///Indicates whether the file content of this package has been available for or subjected to analysis when creating the SPDX document. If false indicates packages that represent metadata or URI references to a project, product, artifact, distribution or a component. If set to false, the package must not contain any files.
    #[serde(rename = "filesAnalyzed", default, skip_serializing_if = "Option::is_none")]
    pub files_analyzed: Option<bool>,
    ///DEPRECATED: use relationships instead of this field. Indicates that a particular file belongs to a package.
    #[serde(rename = "hasFiles", default, skip_serializing_if = "Vec::is_empty")]
    pub has_files: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub homepage: Option<String>,
    ///The licenseComments property allows the preparer of the SPDX document to describe why the licensing in spdx:licenseConcluded was chosen.
    #[serde(
        rename = "licenseComments",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub license_comments: Option<String>,
    /**License expression for licenseConcluded. See SPDX Annex D for the license expression syntax.  The licensing that the preparer of this SPDX document has concluded, based on the evidence, actually applies to the SPDX Item.

If the licenseConcluded field is not present for an SPDX Item, it implies an equivalent meaning to NOASSERTION.*/
    #[serde(
        rename = "licenseConcluded",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub license_concluded: Option<String>,
    ///License expression for licenseDeclared. See SPDX Annex D for the license expression syntax.  The licensing that the creators of the software in the package, or the packager, have declared. Declarations by the original software creator should be preferred, if they exist.
    #[serde(
        rename = "licenseDeclared",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub license_declared: Option<String>,
    /**The licensing information that was discovered directly within the package. There will be an instance of this property for each distinct value of alllicenseInfoInFile properties of all files contained in the package.

If the licenseInfoFromFiles field is not present for a package and filesAnalyzed property for that same package is true or omitted, it implies an equivalent meaning to NOASSERTION.*/
    #[serde(
        rename = "licenseInfoFromFiles",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub license_info_from_files: Vec<String>,
    ///Identify name of this SpdxElement.
    pub name: String,
    ///The name and, optionally, contact information of the person or organization that originally created the package. Values of this property must conform to the agent and tool syntax.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub originator: Option<String>,
    ///The base name of the package file name. For example, zlib-1.2.5.tar.gz.
    #[serde(
        rename = "packageFileName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub package_file_name: Option<String>,
    #[serde(
        rename = "packageVerificationCode",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub package_verification_code: Option<Spdx23PackagesItemPackageVerificationCode>,
    ///This field provides information about the primary purpose of the identified package. Package Purpose is intrinsic to how the package is being used rather than the content of the package.
    #[serde(
        rename = "primaryPackagePurpose",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub primary_package_purpose: Option<Spdx23PackagesItemPrimaryPackagePurpose>,
    ///This field provides a place for recording the date the package was released.
    #[serde(rename = "releaseDate", default, skip_serializing_if = "Option::is_none")]
    pub release_date: Option<String>,
    ///Allows the producer(s) of the SPDX document to describe how the package was acquired and/or changed from the original source.
    #[serde(rename = "sourceInfo", default, skip_serializing_if = "Option::is_none")]
    pub source_info: Option<String>,
    ///Uniquely identify any element in an SPDX document which may be referenced by other elements.
    #[serde(rename = "SPDXID")]
    pub spdxid: String,
    ///Provides a short description of the package.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    ///The name and, optionally, contact information of the person or organization who was the immediate supplier of this package to the recipient. The supplier may be different than originator when the software has been repackaged. Values of this property must conform to the agent and tool syntax.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub supplier: Option<String>,
    ///This field provides a place for recording the end of the support period for a package from the supplier.
    #[serde(rename = "validUntilDate", default, skip_serializing_if = "Option::is_none")]
    pub valid_until_date: Option<String>,
    ///Provides an indication of the version of the package that is described by this SpdxDocument.
    #[serde(rename = "versionInfo", default, skip_serializing_if = "Option::is_none")]
    pub version_info: Option<String>,
}
impl From<&Spdx23PackagesItem> for Spdx23PackagesItem {
    fn from(value: &Spdx23PackagesItem) -> Self {
        value.clone()
    }
}
impl Spdx23PackagesItem {
    pub fn builder() -> builder::Spdx23PackagesItem {
        builder::Spdx23PackagesItem::default()
    }
}
///An Annotation is a comment on an SpdxItem by an agent.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct Spdx23PackagesItemAnnotationsItem {
    ///Identify when the comment was made. This is to be specified according to the combined date and time in the UTC format, as specified in the ISO 8601 standard.
    #[serde(rename = "annotationDate")]
    pub annotation_date: String,
    ///Type of the annotation.
    #[serde(rename = "annotationType")]
    pub annotation_type: Spdx23PackagesItemAnnotationsItemAnnotationType,
    ///This field identifies the person, organization, or tool that has commented on a file, package, snippet, or the entire document.
    pub annotator: String,
    pub comment: String,
}
impl From<&Spdx23PackagesItemAnnotationsItem> for Spdx23PackagesItemAnnotationsItem {
    fn from(value: &Spdx23PackagesItemAnnotationsItem) -> Self {
        value.clone()
    }
}
impl Spdx23PackagesItemAnnotationsItem {
    pub fn builder() -> builder::Spdx23PackagesItemAnnotationsItem {
        builder::Spdx23PackagesItemAnnotationsItem::default()
    }
}
///Type of the annotation.
#[derive(
    Clone,
    Copy,
    Debug,
    Deserialize,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
    Serialize,
    schemars::JsonSchema
)]
pub enum Spdx23PackagesItemAnnotationsItemAnnotationType {
    #[serde(rename = "OTHER")]
    Other,
    #[serde(rename = "REVIEW")]
    Review,
}
impl From<&Spdx23PackagesItemAnnotationsItemAnnotationType>
for Spdx23PackagesItemAnnotationsItemAnnotationType {
    fn from(value: &Spdx23PackagesItemAnnotationsItemAnnotationType) -> Self {
        value.clone()
    }
}
impl ToString for Spdx23PackagesItemAnnotationsItemAnnotationType {
    fn to_string(&self) -> String {
        match *self {
            Self::Other => "OTHER".to_string(),
            Self::Review => "REVIEW".to_string(),
        }
    }
}
impl std::str::FromStr for Spdx23PackagesItemAnnotationsItemAnnotationType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "OTHER" => Ok(Self::Other),
            "REVIEW" => Ok(Self::Review),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for Spdx23PackagesItemAnnotationsItemAnnotationType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for Spdx23PackagesItemAnnotationsItemAnnotationType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for Spdx23PackagesItemAnnotationsItemAnnotationType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
///A Checksum is value that allows the contents of a file to be authenticated. Even small changes to the content of the file will change its checksum. This class allows the results of a variety of checksum and cryptographic message digest algorithms to be represented.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct Spdx23PackagesItemChecksumsItem {
    ///Identifies the algorithm used to produce the subject Checksum. Currently, SHA-1 is the only supported algorithm. It is anticipated that other algorithms will be supported at a later time.
    pub algorithm: Spdx23PackagesItemChecksumsItemAlgorithm,
    ///The checksumValue property provides a lower case hexidecimal encoded digest value produced using a specific algorithm.
    #[serde(rename = "checksumValue")]
    pub checksum_value: String,
}
impl From<&Spdx23PackagesItemChecksumsItem> for Spdx23PackagesItemChecksumsItem {
    fn from(value: &Spdx23PackagesItemChecksumsItem) -> Self {
        value.clone()
    }
}
impl Spdx23PackagesItemChecksumsItem {
    pub fn builder() -> builder::Spdx23PackagesItemChecksumsItem {
        builder::Spdx23PackagesItemChecksumsItem::default()
    }
}
///Identifies the algorithm used to produce the subject Checksum. Currently, SHA-1 is the only supported algorithm. It is anticipated that other algorithms will be supported at a later time.
#[derive(
    Clone,
    Copy,
    Debug,
    Deserialize,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
    Serialize,
    schemars::JsonSchema
)]
pub enum Spdx23PackagesItemChecksumsItemAlgorithm {
    #[serde(rename = "SHA1")]
    Sha1,
    #[serde(rename = "BLAKE3")]
    Blake3,
    #[serde(rename = "SHA3-384")]
    Sha3384,
    #[serde(rename = "SHA256")]
    Sha256,
    #[serde(rename = "SHA384")]
    Sha384,
    #[serde(rename = "BLAKE2b-512")]
    Blake2b512,
    #[serde(rename = "BLAKE2b-256")]
    Blake2b256,
    #[serde(rename = "SHA3-512")]
    Sha3512,
    #[serde(rename = "MD2")]
    Md2,
    #[serde(rename = "ADLER32")]
    Adler32,
    #[serde(rename = "MD4")]
    Md4,
    #[serde(rename = "SHA3-256")]
    Sha3256,
    #[serde(rename = "BLAKE2b-384")]
    Blake2b384,
    #[serde(rename = "SHA512")]
    Sha512,
    #[serde(rename = "MD6")]
    Md6,
    #[serde(rename = "MD5")]
    Md5,
    #[serde(rename = "SHA224")]
    Sha224,
}
impl From<&Spdx23PackagesItemChecksumsItemAlgorithm>
for Spdx23PackagesItemChecksumsItemAlgorithm {
    fn from(value: &Spdx23PackagesItemChecksumsItemAlgorithm) -> Self {
        value.clone()
    }
}
impl ToString for Spdx23PackagesItemChecksumsItemAlgorithm {
    fn to_string(&self) -> String {
        match *self {
            Self::Sha1 => "SHA1".to_string(),
            Self::Blake3 => "BLAKE3".to_string(),
            Self::Sha3384 => "SHA3-384".to_string(),
            Self::Sha256 => "SHA256".to_string(),
            Self::Sha384 => "SHA384".to_string(),
            Self::Blake2b512 => "BLAKE2b-512".to_string(),
            Self::Blake2b256 => "BLAKE2b-256".to_string(),
            Self::Sha3512 => "SHA3-512".to_string(),
            Self::Md2 => "MD2".to_string(),
            Self::Adler32 => "ADLER32".to_string(),
            Self::Md4 => "MD4".to_string(),
            Self::Sha3256 => "SHA3-256".to_string(),
            Self::Blake2b384 => "BLAKE2b-384".to_string(),
            Self::Sha512 => "SHA512".to_string(),
            Self::Md6 => "MD6".to_string(),
            Self::Md5 => "MD5".to_string(),
            Self::Sha224 => "SHA224".to_string(),
        }
    }
}
impl std::str::FromStr for Spdx23PackagesItemChecksumsItemAlgorithm {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "SHA1" => Ok(Self::Sha1),
            "BLAKE3" => Ok(Self::Blake3),
            "SHA3-384" => Ok(Self::Sha3384),
            "SHA256" => Ok(Self::Sha256),
            "SHA384" => Ok(Self::Sha384),
            "BLAKE2b-512" => Ok(Self::Blake2b512),
            "BLAKE2b-256" => Ok(Self::Blake2b256),
            "SHA3-512" => Ok(Self::Sha3512),
            "MD2" => Ok(Self::Md2),
            "ADLER32" => Ok(Self::Adler32),
            "MD4" => Ok(Self::Md4),
            "SHA3-256" => Ok(Self::Sha3256),
            "BLAKE2b-384" => Ok(Self::Blake2b384),
            "SHA512" => Ok(Self::Sha512),
            "MD6" => Ok(Self::Md6),
            "MD5" => Ok(Self::Md5),
            "SHA224" => Ok(Self::Sha224),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for Spdx23PackagesItemChecksumsItemAlgorithm {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for Spdx23PackagesItemChecksumsItemAlgorithm {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for Spdx23PackagesItemChecksumsItemAlgorithm {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
///An External Reference allows a Package to reference an external source of additional information, metadata, enumerations, asset identifiers, or downloadable content believed to be relevant to the Package.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct Spdx23PackagesItemExternalRefsItem {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    ///Category for the external reference
    #[serde(rename = "referenceCategory")]
    pub reference_category: Spdx23PackagesItemExternalRefsItemReferenceCategory,
    ///The unique string with no spaces necessary to access the package-specific information, metadata, or content within the target location. The format of the locator is subject to constraints defined by the <type>.
    #[serde(rename = "referenceLocator")]
    pub reference_locator: String,
    ///Type of the external reference. These are defined in an appendix in the SPDX specification.
    #[serde(rename = "referenceType")]
    pub reference_type: String,
}
impl From<&Spdx23PackagesItemExternalRefsItem> for Spdx23PackagesItemExternalRefsItem {
    fn from(value: &Spdx23PackagesItemExternalRefsItem) -> Self {
        value.clone()
    }
}
impl Spdx23PackagesItemExternalRefsItem {
    pub fn builder() -> builder::Spdx23PackagesItemExternalRefsItem {
        builder::Spdx23PackagesItemExternalRefsItem::default()
    }
}
///Category for the external reference
#[derive(
    Clone,
    Copy,
    Debug,
    Deserialize,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
    Serialize,
    schemars::JsonSchema
)]
pub enum Spdx23PackagesItemExternalRefsItemReferenceCategory {
    #[serde(rename = "OTHER")]
    Other,
    #[serde(rename = "PERSISTENT-ID")]
    PersistentId,
    #[serde(rename = "SECURITY")]
    Security,
    #[serde(rename = "PACKAGE-MANAGER")]
    PackageManager,
}
impl From<&Spdx23PackagesItemExternalRefsItemReferenceCategory>
for Spdx23PackagesItemExternalRefsItemReferenceCategory {
    fn from(value: &Spdx23PackagesItemExternalRefsItemReferenceCategory) -> Self {
        value.clone()
    }
}
impl ToString for Spdx23PackagesItemExternalRefsItemReferenceCategory {
    fn to_string(&self) -> String {
        match *self {
            Self::Other => "OTHER".to_string(),
            Self::PersistentId => "PERSISTENT-ID".to_string(),
            Self::Security => "SECURITY".to_string(),
            Self::PackageManager => "PACKAGE-MANAGER".to_string(),
        }
    }
}
impl std::str::FromStr for Spdx23PackagesItemExternalRefsItemReferenceCategory {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "OTHER" => Ok(Self::Other),
            "PERSISTENT-ID" => Ok(Self::PersistentId),
            "PERSISTENT_ID" => Ok(Self::PersistentId),
            "SECURITY" => Ok(Self::Security),
            "PACKAGE-MANAGER" => Ok(Self::PackageManager),
            "PACKAGE_MANAGER" => Ok(Self::PackageManager),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
for Spdx23PackagesItemExternalRefsItemReferenceCategory {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
for Spdx23PackagesItemExternalRefsItemReferenceCategory {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
for Spdx23PackagesItemExternalRefsItemReferenceCategory {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
///A manifest based verification code (the algorithm is defined in section 4.7 of the full specification) of the SPDX Item. This allows consumers of this data and/or database to determine if an SPDX item they have in hand is identical to the SPDX item from which the data was produced. This algorithm works even if the SPDX document is included in the SPDX item.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct Spdx23PackagesItemPackageVerificationCode {
    ///A file that was excluded when calculating the package verification code. This is usually a file containing SPDX data regarding the package. If a package contains more than one SPDX file all SPDX files must be excluded from the package verification code. If this is not done it would be impossible to correctly calculate the verification codes in both files.
    #[serde(
        rename = "packageVerificationCodeExcludedFiles",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub package_verification_code_excluded_files: Vec<String>,
    ///The actual package verification code as a hex encoded value.
    #[serde(rename = "packageVerificationCodeValue")]
    pub package_verification_code_value: String,
}
impl From<&Spdx23PackagesItemPackageVerificationCode>
for Spdx23PackagesItemPackageVerificationCode {
    fn from(value: &Spdx23PackagesItemPackageVerificationCode) -> Self {
        value.clone()
    }
}
impl Spdx23PackagesItemPackageVerificationCode {
    pub fn builder() -> builder::Spdx23PackagesItemPackageVerificationCode {
        builder::Spdx23PackagesItemPackageVerificationCode::default()
    }
}
///This field provides information about the primary purpose of the identified package. Package Purpose is intrinsic to how the package is being used rather than the content of the package.
#[derive(
    Clone,
    Copy,
    Debug,
    Deserialize,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
    Serialize,
    schemars::JsonSchema
)]
pub enum Spdx23PackagesItemPrimaryPackagePurpose {
    #[serde(rename = "OTHER")]
    Other,
    #[serde(rename = "INSTALL")]
    Install,
    #[serde(rename = "ARCHIVE")]
    Archive,
    #[serde(rename = "FIRMWARE")]
    Firmware,
    #[serde(rename = "APPLICATION")]
    Application,
    #[serde(rename = "FRAMEWORK")]
    Framework,
    #[serde(rename = "LIBRARY")]
    Library,
    #[serde(rename = "CONTAINER")]
    Container,
    #[serde(rename = "SOURCE")]
    Source,
    #[serde(rename = "DEVICE")]
    Device,
    #[serde(rename = "OPERATING_SYSTEM")]
    OperatingSystem,
    #[serde(rename = "FILE")]
    File,
}
impl From<&Spdx23PackagesItemPrimaryPackagePurpose>
for Spdx23PackagesItemPrimaryPackagePurpose {
    fn from(value: &Spdx23PackagesItemPrimaryPackagePurpose) -> Self {
        value.clone()
    }
}
impl ToString for Spdx23PackagesItemPrimaryPackagePurpose {
    fn to_string(&self) -> String {
        match *self {
            Self::Other => "OTHER".to_string(),
            Self::Install => "INSTALL".to_string(),
            Self::Archive => "ARCHIVE".to_string(),
            Self::Firmware => "FIRMWARE".to_string(),
            Self::Application => "APPLICATION".to_string(),
            Self::Framework => "FRAMEWORK".to_string(),
            Self::Library => "LIBRARY".to_string(),
            Self::Container => "CONTAINER".to_string(),
            Self::Source => "SOURCE".to_string(),
            Self::Device => "DEVICE".to_string(),
            Self::OperatingSystem => "OPERATING_SYSTEM".to_string(),
            Self::File => "FILE".to_string(),
        }
    }
}
impl std::str::FromStr for Spdx23PackagesItemPrimaryPackagePurpose {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "OTHER" => Ok(Self::Other),
            "INSTALL" => Ok(Self::Install),
            "ARCHIVE" => Ok(Self::Archive),
            "FIRMWARE" => Ok(Self::Firmware),
            "APPLICATION" => Ok(Self::Application),
            "FRAMEWORK" => Ok(Self::Framework),
            "LIBRARY" => Ok(Self::Library),
            "CONTAINER" => Ok(Self::Container),
            "SOURCE" => Ok(Self::Source),
            "DEVICE" => Ok(Self::Device),
            "OPERATING_SYSTEM" => Ok(Self::OperatingSystem),
            "FILE" => Ok(Self::File),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for Spdx23PackagesItemPrimaryPackagePurpose {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for Spdx23PackagesItemPrimaryPackagePurpose {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for Spdx23PackagesItemPrimaryPackagePurpose {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct Spdx23RelationshipsItem {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    ///SPDX ID for SpdxElement.  A related SpdxElement.
    #[serde(rename = "relatedSpdxElement")]
    pub related_spdx_element: String,
    ///Describes the type of relationship between two SPDX elements.
    #[serde(rename = "relationshipType")]
    pub relationship_type: Spdx23RelationshipsItemRelationshipType,
    ///Id to which the SPDX element is related
    #[serde(rename = "spdxElementId")]
    pub spdx_element_id: String,
}
impl From<&Spdx23RelationshipsItem> for Spdx23RelationshipsItem {
    fn from(value: &Spdx23RelationshipsItem) -> Self {
        value.clone()
    }
}
impl Spdx23RelationshipsItem {
    pub fn builder() -> builder::Spdx23RelationshipsItem {
        builder::Spdx23RelationshipsItem::default()
    }
}
///Describes the type of relationship between two SPDX elements.
#[derive(
    Clone,
    Copy,
    Debug,
    Deserialize,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
    Serialize,
    schemars::JsonSchema
)]
pub enum Spdx23RelationshipsItemRelationshipType {
    #[serde(rename = "VARIANT_OF")]
    VariantOf,
    #[serde(rename = "COPY_OF")]
    CopyOf,
    #[serde(rename = "PATCH_FOR")]
    PatchFor,
    #[serde(rename = "TEST_DEPENDENCY_OF")]
    TestDependencyOf,
    #[serde(rename = "CONTAINED_BY")]
    ContainedBy,
    #[serde(rename = "DATA_FILE_OF")]
    DataFileOf,
    #[serde(rename = "OPTIONAL_COMPONENT_OF")]
    OptionalComponentOf,
    #[serde(rename = "ANCESTOR_OF")]
    AncestorOf,
    #[serde(rename = "GENERATES")]
    Generates,
    #[serde(rename = "CONTAINS")]
    Contains,
    #[serde(rename = "OPTIONAL_DEPENDENCY_OF")]
    OptionalDependencyOf,
    #[serde(rename = "FILE_ADDED")]
    FileAdded,
    #[serde(rename = "REQUIREMENT_DESCRIPTION_FOR")]
    RequirementDescriptionFor,
    #[serde(rename = "DEV_DEPENDENCY_OF")]
    DevDependencyOf,
    #[serde(rename = "DEPENDENCY_OF")]
    DependencyOf,
    #[serde(rename = "BUILD_DEPENDENCY_OF")]
    BuildDependencyOf,
    #[serde(rename = "DESCRIBES")]
    Describes,
    #[serde(rename = "PREREQUISITE_FOR")]
    PrerequisiteFor,
    #[serde(rename = "HAS_PREREQUISITE")]
    HasPrerequisite,
    #[serde(rename = "PROVIDED_DEPENDENCY_OF")]
    ProvidedDependencyOf,
    #[serde(rename = "DYNAMIC_LINK")]
    DynamicLink,
    #[serde(rename = "DESCRIBED_BY")]
    DescribedBy,
    #[serde(rename = "METAFILE_OF")]
    MetafileOf,
    #[serde(rename = "DEPENDENCY_MANIFEST_OF")]
    DependencyManifestOf,
    #[serde(rename = "PATCH_APPLIED")]
    PatchApplied,
    #[serde(rename = "RUNTIME_DEPENDENCY_OF")]
    RuntimeDependencyOf,
    #[serde(rename = "TEST_OF")]
    TestOf,
    #[serde(rename = "TEST_TOOL_OF")]
    TestToolOf,
    #[serde(rename = "DEPENDS_ON")]
    DependsOn,
    #[serde(rename = "SPECIFICATION_FOR")]
    SpecificationFor,
    #[serde(rename = "FILE_MODIFIED")]
    FileModified,
    #[serde(rename = "DISTRIBUTION_ARTIFACT")]
    DistributionArtifact,
    #[serde(rename = "AMENDS")]
    Amends,
    #[serde(rename = "DOCUMENTATION_OF")]
    DocumentationOf,
    #[serde(rename = "GENERATED_FROM")]
    GeneratedFrom,
    #[serde(rename = "STATIC_LINK")]
    StaticLink,
    #[serde(rename = "OTHER")]
    Other,
    #[serde(rename = "BUILD_TOOL_OF")]
    BuildToolOf,
    #[serde(rename = "TEST_CASE_OF")]
    TestCaseOf,
    #[serde(rename = "PACKAGE_OF")]
    PackageOf,
    #[serde(rename = "DESCENDANT_OF")]
    DescendantOf,
    #[serde(rename = "FILE_DELETED")]
    FileDeleted,
    #[serde(rename = "EXPANDED_FROM_ARCHIVE")]
    ExpandedFromArchive,
    #[serde(rename = "DEV_TOOL_OF")]
    DevToolOf,
    #[serde(rename = "EXAMPLE_OF")]
    ExampleOf,
}
impl From<&Spdx23RelationshipsItemRelationshipType>
for Spdx23RelationshipsItemRelationshipType {
    fn from(value: &Spdx23RelationshipsItemRelationshipType) -> Self {
        value.clone()
    }
}
impl ToString for Spdx23RelationshipsItemRelationshipType {
    fn to_string(&self) -> String {
        match *self {
            Self::VariantOf => "VARIANT_OF".to_string(),
            Self::CopyOf => "COPY_OF".to_string(),
            Self::PatchFor => "PATCH_FOR".to_string(),
            Self::TestDependencyOf => "TEST_DEPENDENCY_OF".to_string(),
            Self::ContainedBy => "CONTAINED_BY".to_string(),
            Self::DataFileOf => "DATA_FILE_OF".to_string(),
            Self::OptionalComponentOf => "OPTIONAL_COMPONENT_OF".to_string(),
            Self::AncestorOf => "ANCESTOR_OF".to_string(),
            Self::Generates => "GENERATES".to_string(),
            Self::Contains => "CONTAINS".to_string(),
            Self::OptionalDependencyOf => "OPTIONAL_DEPENDENCY_OF".to_string(),
            Self::FileAdded => "FILE_ADDED".to_string(),
            Self::RequirementDescriptionFor => "REQUIREMENT_DESCRIPTION_FOR".to_string(),
            Self::DevDependencyOf => "DEV_DEPENDENCY_OF".to_string(),
            Self::DependencyOf => "DEPENDENCY_OF".to_string(),
            Self::BuildDependencyOf => "BUILD_DEPENDENCY_OF".to_string(),
            Self::Describes => "DESCRIBES".to_string(),
            Self::PrerequisiteFor => "PREREQUISITE_FOR".to_string(),
            Self::HasPrerequisite => "HAS_PREREQUISITE".to_string(),
            Self::ProvidedDependencyOf => "PROVIDED_DEPENDENCY_OF".to_string(),
            Self::DynamicLink => "DYNAMIC_LINK".to_string(),
            Self::DescribedBy => "DESCRIBED_BY".to_string(),
            Self::MetafileOf => "METAFILE_OF".to_string(),
            Self::DependencyManifestOf => "DEPENDENCY_MANIFEST_OF".to_string(),
            Self::PatchApplied => "PATCH_APPLIED".to_string(),
            Self::RuntimeDependencyOf => "RUNTIME_DEPENDENCY_OF".to_string(),
            Self::TestOf => "TEST_OF".to_string(),
            Self::TestToolOf => "TEST_TOOL_OF".to_string(),
            Self::DependsOn => "DEPENDS_ON".to_string(),
            Self::SpecificationFor => "SPECIFICATION_FOR".to_string(),
            Self::FileModified => "FILE_MODIFIED".to_string(),
            Self::DistributionArtifact => "DISTRIBUTION_ARTIFACT".to_string(),
            Self::Amends => "AMENDS".to_string(),
            Self::DocumentationOf => "DOCUMENTATION_OF".to_string(),
            Self::GeneratedFrom => "GENERATED_FROM".to_string(),
            Self::StaticLink => "STATIC_LINK".to_string(),
            Self::Other => "OTHER".to_string(),
            Self::BuildToolOf => "BUILD_TOOL_OF".to_string(),
            Self::TestCaseOf => "TEST_CASE_OF".to_string(),
            Self::PackageOf => "PACKAGE_OF".to_string(),
            Self::DescendantOf => "DESCENDANT_OF".to_string(),
            Self::FileDeleted => "FILE_DELETED".to_string(),
            Self::ExpandedFromArchive => "EXPANDED_FROM_ARCHIVE".to_string(),
            Self::DevToolOf => "DEV_TOOL_OF".to_string(),
            Self::ExampleOf => "EXAMPLE_OF".to_string(),
        }
    }
}
impl std::str::FromStr for Spdx23RelationshipsItemRelationshipType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "VARIANT_OF" => Ok(Self::VariantOf),
            "COPY_OF" => Ok(Self::CopyOf),
            "PATCH_FOR" => Ok(Self::PatchFor),
            "TEST_DEPENDENCY_OF" => Ok(Self::TestDependencyOf),
            "CONTAINED_BY" => Ok(Self::ContainedBy),
            "DATA_FILE_OF" => Ok(Self::DataFileOf),
            "OPTIONAL_COMPONENT_OF" => Ok(Self::OptionalComponentOf),
            "ANCESTOR_OF" => Ok(Self::AncestorOf),
            "GENERATES" => Ok(Self::Generates),
            "CONTAINS" => Ok(Self::Contains),
            "OPTIONAL_DEPENDENCY_OF" => Ok(Self::OptionalDependencyOf),
            "FILE_ADDED" => Ok(Self::FileAdded),
            "REQUIREMENT_DESCRIPTION_FOR" => Ok(Self::RequirementDescriptionFor),
            "DEV_DEPENDENCY_OF" => Ok(Self::DevDependencyOf),
            "DEPENDENCY_OF" => Ok(Self::DependencyOf),
            "BUILD_DEPENDENCY_OF" => Ok(Self::BuildDependencyOf),
            "DESCRIBES" => Ok(Self::Describes),
            "PREREQUISITE_FOR" => Ok(Self::PrerequisiteFor),
            "HAS_PREREQUISITE" => Ok(Self::HasPrerequisite),
            "PROVIDED_DEPENDENCY_OF" => Ok(Self::ProvidedDependencyOf),
            "DYNAMIC_LINK" => Ok(Self::DynamicLink),
            "DESCRIBED_BY" => Ok(Self::DescribedBy),
            "METAFILE_OF" => Ok(Self::MetafileOf),
            "DEPENDENCY_MANIFEST_OF" => Ok(Self::DependencyManifestOf),
            "PATCH_APPLIED" => Ok(Self::PatchApplied),
            "RUNTIME_DEPENDENCY_OF" => Ok(Self::RuntimeDependencyOf),
            "TEST_OF" => Ok(Self::TestOf),
            "TEST_TOOL_OF" => Ok(Self::TestToolOf),
            "DEPENDS_ON" => Ok(Self::DependsOn),
            "SPECIFICATION_FOR" => Ok(Self::SpecificationFor),
            "FILE_MODIFIED" => Ok(Self::FileModified),
            "DISTRIBUTION_ARTIFACT" => Ok(Self::DistributionArtifact),
            "AMENDS" => Ok(Self::Amends),
            "DOCUMENTATION_OF" => Ok(Self::DocumentationOf),
            "GENERATED_FROM" => Ok(Self::GeneratedFrom),
            "STATIC_LINK" => Ok(Self::StaticLink),
            "OTHER" => Ok(Self::Other),
            "BUILD_TOOL_OF" => Ok(Self::BuildToolOf),
            "TEST_CASE_OF" => Ok(Self::TestCaseOf),
            "PACKAGE_OF" => Ok(Self::PackageOf),
            "DESCENDANT_OF" => Ok(Self::DescendantOf),
            "FILE_DELETED" => Ok(Self::FileDeleted),
            "EXPANDED_FROM_ARCHIVE" => Ok(Self::ExpandedFromArchive),
            "DEV_TOOL_OF" => Ok(Self::DevToolOf),
            "EXAMPLE_OF" => Ok(Self::ExampleOf),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for Spdx23RelationshipsItemRelationshipType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for Spdx23RelationshipsItemRelationshipType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for Spdx23RelationshipsItemRelationshipType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
///This class has been deprecated in favor of an Annotation with an Annotation type of review.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct Spdx23ReviewedsItem {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    ///The date and time at which the SpdxDocument was reviewed. This value must be in UTC and have 'Z' as its timezone indicator.
    #[serde(rename = "reviewDate")]
    pub review_date: String,
    ///The name and, optionally, contact information of the person who performed the review. Values of this property must conform to the agent and tool syntax.  The reviewer property is deprecated in favor of Annotation with an annotationType review.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reviewer: Option<String>,
}
impl From<&Spdx23ReviewedsItem> for Spdx23ReviewedsItem {
    fn from(value: &Spdx23ReviewedsItem) -> Self {
        value.clone()
    }
}
impl Spdx23ReviewedsItem {
    pub fn builder() -> builder::Spdx23ReviewedsItem {
        builder::Spdx23ReviewedsItem::default()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct Spdx23SnippetsItem {
    ///Provide additional information about an SpdxElement.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub annotations: Vec<Spdx23SnippetsItemAnnotationsItem>,
    ///This field provides a place for the SPDX data creator to record acknowledgements that may be required to be communicated in some contexts. This is not meant to include the actual complete license text (see licenseConculded and licenseDeclared), and may or may not include copyright notices (see also copyrightText). The SPDX data creator may use this field to record other acknowledgements, such as particular clauses from license texts, which may be necessary or desirable to reproduce.
    #[serde(rename = "attributionTexts", default, skip_serializing_if = "Vec::is_empty")]
    pub attribution_texts: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    /**The text of copyright declarations recited in the package, file or snippet.

If the copyrightText field is not present, it implies an equivalent meaning to NOASSERTION.*/
    #[serde(rename = "copyrightText", default, skip_serializing_if = "Option::is_none")]
    pub copyright_text: Option<String>,
    ///The licenseComments property allows the preparer of the SPDX document to describe why the licensing in spdx:licenseConcluded was chosen.
    #[serde(
        rename = "licenseComments",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub license_comments: Option<String>,
    /**License expression for licenseConcluded. See SPDX Annex D for the license expression syntax.  The licensing that the preparer of this SPDX document has concluded, based on the evidence, actually applies to the SPDX Item.

If the licenseConcluded field is not present for an SPDX Item, it implies an equivalent meaning to NOASSERTION.*/
    #[serde(
        rename = "licenseConcluded",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub license_concluded: Option<String>,
    /**Licensing information that was discovered directly in the subject snippet. This is also considered a declared license for the snippet.

If the licenseInfoInSnippet field is not present for a snippet, it implies an equivalent meaning to NOASSERTION.*/
    #[serde(
        rename = "licenseInfoInSnippets",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub license_info_in_snippets: Vec<String>,
    ///Identify name of this SpdxElement.
    pub name: String,
    ///This field defines the byte range in the original host file (in X.2) that the snippet information applies to
    pub ranges: Vec<Spdx23SnippetsItemRangesItem>,
    ///SPDX ID for File.  File containing the SPDX element (e.g. the file contaning a snippet).
    #[serde(rename = "snippetFromFile")]
    pub snippet_from_file: String,
    ///Uniquely identify any element in an SPDX document which may be referenced by other elements.
    #[serde(rename = "SPDXID")]
    pub spdxid: String,
}
impl From<&Spdx23SnippetsItem> for Spdx23SnippetsItem {
    fn from(value: &Spdx23SnippetsItem) -> Self {
        value.clone()
    }
}
impl Spdx23SnippetsItem {
    pub fn builder() -> builder::Spdx23SnippetsItem {
        builder::Spdx23SnippetsItem::default()
    }
}
///An Annotation is a comment on an SpdxItem by an agent.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct Spdx23SnippetsItemAnnotationsItem {
    ///Identify when the comment was made. This is to be specified according to the combined date and time in the UTC format, as specified in the ISO 8601 standard.
    #[serde(rename = "annotationDate")]
    pub annotation_date: String,
    ///Type of the annotation.
    #[serde(rename = "annotationType")]
    pub annotation_type: Spdx23SnippetsItemAnnotationsItemAnnotationType,
    ///This field identifies the person, organization, or tool that has commented on a file, package, snippet, or the entire document.
    pub annotator: String,
    pub comment: String,
}
impl From<&Spdx23SnippetsItemAnnotationsItem> for Spdx23SnippetsItemAnnotationsItem {
    fn from(value: &Spdx23SnippetsItemAnnotationsItem) -> Self {
        value.clone()
    }
}
impl Spdx23SnippetsItemAnnotationsItem {
    pub fn builder() -> builder::Spdx23SnippetsItemAnnotationsItem {
        builder::Spdx23SnippetsItemAnnotationsItem::default()
    }
}
///Type of the annotation.
#[derive(
    Clone,
    Copy,
    Debug,
    Deserialize,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
    Serialize,
    schemars::JsonSchema
)]
pub enum Spdx23SnippetsItemAnnotationsItemAnnotationType {
    #[serde(rename = "OTHER")]
    Other,
    #[serde(rename = "REVIEW")]
    Review,
}
impl From<&Spdx23SnippetsItemAnnotationsItemAnnotationType>
for Spdx23SnippetsItemAnnotationsItemAnnotationType {
    fn from(value: &Spdx23SnippetsItemAnnotationsItemAnnotationType) -> Self {
        value.clone()
    }
}
impl ToString for Spdx23SnippetsItemAnnotationsItemAnnotationType {
    fn to_string(&self) -> String {
        match *self {
            Self::Other => "OTHER".to_string(),
            Self::Review => "REVIEW".to_string(),
        }
    }
}
impl std::str::FromStr for Spdx23SnippetsItemAnnotationsItemAnnotationType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "OTHER" => Ok(Self::Other),
            "REVIEW" => Ok(Self::Review),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for Spdx23SnippetsItemAnnotationsItemAnnotationType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for Spdx23SnippetsItemAnnotationsItemAnnotationType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for Spdx23SnippetsItemAnnotationsItemAnnotationType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct Spdx23SnippetsItemRangesItem {
    #[serde(rename = "endPointer")]
    pub end_pointer: Spdx23SnippetsItemRangesItemEndPointer,
    #[serde(rename = "startPointer")]
    pub start_pointer: Spdx23SnippetsItemRangesItemStartPointer,
}
impl From<&Spdx23SnippetsItemRangesItem> for Spdx23SnippetsItemRangesItem {
    fn from(value: &Spdx23SnippetsItemRangesItem) -> Self {
        value.clone()
    }
}
impl Spdx23SnippetsItemRangesItem {
    pub fn builder() -> builder::Spdx23SnippetsItemRangesItem {
        builder::Spdx23SnippetsItemRangesItem::default()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct Spdx23SnippetsItemRangesItemEndPointer {
    ///line number offset in the file
    #[serde(rename = "lineNumber", default, skip_serializing_if = "Option::is_none")]
    pub line_number: Option<i64>,
    ///Byte offset in the file
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub offset: Option<i64>,
    ///SPDX ID for File
    pub reference: String,
}
impl From<&Spdx23SnippetsItemRangesItemEndPointer>
for Spdx23SnippetsItemRangesItemEndPointer {
    fn from(value: &Spdx23SnippetsItemRangesItemEndPointer) -> Self {
        value.clone()
    }
}
impl Spdx23SnippetsItemRangesItemEndPointer {
    pub fn builder() -> builder::Spdx23SnippetsItemRangesItemEndPointer {
        builder::Spdx23SnippetsItemRangesItemEndPointer::default()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct Spdx23SnippetsItemRangesItemStartPointer {
    ///line number offset in the file
    #[serde(rename = "lineNumber", default, skip_serializing_if = "Option::is_none")]
    pub line_number: Option<i64>,
    ///Byte offset in the file
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub offset: Option<i64>,
    ///SPDX ID for File
    pub reference: String,
}
impl From<&Spdx23SnippetsItemRangesItemStartPointer>
for Spdx23SnippetsItemRangesItemStartPointer {
    fn from(value: &Spdx23SnippetsItemRangesItemStartPointer) -> Self {
        value.clone()
    }
}
impl Spdx23SnippetsItemRangesItemStartPointer {
    pub fn builder() -> builder::Spdx23SnippetsItemRangesItemStartPointer {
        builder::Spdx23SnippetsItemRangesItemStartPointer::default()
    }
}
pub mod builder {
    #[derive(Clone, Debug)]
    pub struct Spdx23 {
        annotations: Result<Vec<super::Spdx23AnnotationsItem>, String>,
        comment: Result<Option<String>, String>,
        creation_info: Result<super::Spdx23CreationInfo, String>,
        data_license: Result<String, String>,
        document_describes: Result<Vec<String>, String>,
        document_namespace: Result<String, String>,
        external_document_refs: Result<
            Vec<super::Spdx23ExternalDocumentRefsItem>,
            String,
        >,
        files: Result<Vec<super::Spdx23FilesItem>, String>,
        has_extracted_licensing_infos: Result<
            Vec<super::Spdx23HasExtractedLicensingInfosItem>,
            String,
        >,
        name: Result<String, String>,
        packages: Result<Vec<super::Spdx23PackagesItem>, String>,
        relationships: Result<Vec<super::Spdx23RelationshipsItem>, String>,
        revieweds: Result<Vec<super::Spdx23ReviewedsItem>, String>,
        snippets: Result<Vec<super::Spdx23SnippetsItem>, String>,
        spdx_version: Result<String, String>,
        spdxid: Result<String, String>,
    }
    impl Default for Spdx23 {
        fn default() -> Self {
            Self {
                annotations: Ok(Default::default()),
                comment: Ok(Default::default()),
                creation_info: Err("no value supplied for creation_info".to_string()),
                data_license: Err("no value supplied for data_license".to_string()),
                document_describes: Ok(Default::default()),
                document_namespace: Err(
                    "no value supplied for document_namespace".to_string(),
                ),
                external_document_refs: Ok(Default::default()),
                files: Ok(Default::default()),
                has_extracted_licensing_infos: Ok(Default::default()),
                name: Err("no value supplied for name".to_string()),
                packages: Ok(Default::default()),
                relationships: Ok(Default::default()),
                revieweds: Ok(Default::default()),
                snippets: Ok(Default::default()),
                spdx_version: Err("no value supplied for spdx_version".to_string()),
                spdxid: Err("no value supplied for spdxid".to_string()),
            }
        }
    }
    impl Spdx23 {
        pub fn annotations<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Spdx23AnnotationsItem>>,
            T::Error: std::fmt::Display,
        {
            self
                .annotations = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for annotations: {}", e)
                });
            self
        }
        pub fn comment<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .comment = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for comment: {}", e)
                });
            self
        }
        pub fn creation_info<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<super::Spdx23CreationInfo>,
            T::Error: std::fmt::Display,
        {
            self
                .creation_info = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for creation_info: {}", e)
                });
            self
        }
        pub fn data_license<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .data_license = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for data_license: {}", e)
                });
            self
        }
        pub fn document_describes<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .document_describes = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for document_describes: {}", e
                    )
                });
            self
        }
        pub fn document_namespace<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .document_namespace = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for document_namespace: {}", e
                    )
                });
            self
        }
        pub fn external_document_refs<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Spdx23ExternalDocumentRefsItem>>,
            T::Error: std::fmt::Display,
        {
            self
                .external_document_refs = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for external_document_refs: {}",
                        e
                    )
                });
            self
        }
        pub fn files<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Spdx23FilesItem>>,
            T::Error: std::fmt::Display,
        {
            self
                .files = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for files: {}", e)
                });
            self
        }
        pub fn has_extracted_licensing_infos<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Spdx23HasExtractedLicensingInfosItem>>,
            T::Error: std::fmt::Display,
        {
            self
                .has_extracted_licensing_infos = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for has_extracted_licensing_infos: {}",
                        e
                    )
                });
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn packages<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Spdx23PackagesItem>>,
            T::Error: std::fmt::Display,
        {
            self
                .packages = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for packages: {}", e)
                });
            self
        }
        pub fn relationships<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Spdx23RelationshipsItem>>,
            T::Error: std::fmt::Display,
        {
            self
                .relationships = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for relationships: {}", e)
                });
            self
        }
        pub fn revieweds<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Spdx23ReviewedsItem>>,
            T::Error: std::fmt::Display,
        {
            self
                .revieweds = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for revieweds: {}", e)
                });
            self
        }
        pub fn snippets<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Spdx23SnippetsItem>>,
            T::Error: std::fmt::Display,
        {
            self
                .snippets = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for snippets: {}", e)
                });
            self
        }
        pub fn spdx_version<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .spdx_version = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for spdx_version: {}", e)
                });
            self
        }
        pub fn spdxid<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .spdxid = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for spdxid: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx23> for super::Spdx23 {
        type Error = String;
        fn try_from(value: Spdx23) -> Result<Self, String> {
            Ok(Self {
                annotations: value.annotations?,
                comment: value.comment?,
                creation_info: value.creation_info?,
                data_license: value.data_license?,
                document_describes: value.document_describes?,
                document_namespace: value.document_namespace?,
                external_document_refs: value.external_document_refs?,
                files: value.files?,
                has_extracted_licensing_infos: value.has_extracted_licensing_infos?,
                name: value.name?,
                packages: value.packages?,
                relationships: value.relationships?,
                revieweds: value.revieweds?,
                snippets: value.snippets?,
                spdx_version: value.spdx_version?,
                spdxid: value.spdxid?,
            })
        }
    }
    impl From<super::Spdx23> for Spdx23 {
        fn from(value: super::Spdx23) -> Self {
            Self {
                annotations: Ok(value.annotations),
                comment: Ok(value.comment),
                creation_info: Ok(value.creation_info),
                data_license: Ok(value.data_license),
                document_describes: Ok(value.document_describes),
                document_namespace: Ok(value.document_namespace),
                external_document_refs: Ok(value.external_document_refs),
                files: Ok(value.files),
                has_extracted_licensing_infos: Ok(value.has_extracted_licensing_infos),
                name: Ok(value.name),
                packages: Ok(value.packages),
                relationships: Ok(value.relationships),
                revieweds: Ok(value.revieweds),
                snippets: Ok(value.snippets),
                spdx_version: Ok(value.spdx_version),
                spdxid: Ok(value.spdxid),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx23AnnotationsItem {
        annotation_date: Result<String, String>,
        annotation_type: Result<super::Spdx23AnnotationsItemAnnotationType, String>,
        annotator: Result<String, String>,
        comment: Result<String, String>,
    }
    impl Default for Spdx23AnnotationsItem {
        fn default() -> Self {
            Self {
                annotation_date: Err(
                    "no value supplied for annotation_date".to_string(),
                ),
                annotation_type: Err(
                    "no value supplied for annotation_type".to_string(),
                ),
                annotator: Err("no value supplied for annotator".to_string()),
                comment: Err("no value supplied for comment".to_string()),
            }
        }
    }
    impl Spdx23AnnotationsItem {
        pub fn annotation_date<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .annotation_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for annotation_date: {}", e)
                });
            self
        }
        pub fn annotation_type<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<super::Spdx23AnnotationsItemAnnotationType>,
            T::Error: std::fmt::Display,
        {
            self
                .annotation_type = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for annotation_type: {}", e)
                });
            self
        }
        pub fn annotator<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .annotator = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for annotator: {}", e)
                });
            self
        }
        pub fn comment<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .comment = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for comment: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx23AnnotationsItem> for super::Spdx23AnnotationsItem {
        type Error = String;
        fn try_from(value: Spdx23AnnotationsItem) -> Result<Self, String> {
            Ok(Self {
                annotation_date: value.annotation_date?,
                annotation_type: value.annotation_type?,
                annotator: value.annotator?,
                comment: value.comment?,
            })
        }
    }
    impl From<super::Spdx23AnnotationsItem> for Spdx23AnnotationsItem {
        fn from(value: super::Spdx23AnnotationsItem) -> Self {
            Self {
                annotation_date: Ok(value.annotation_date),
                annotation_type: Ok(value.annotation_type),
                annotator: Ok(value.annotator),
                comment: Ok(value.comment),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx23CreationInfo {
        comment: Result<Option<String>, String>,
        created: Result<String, String>,
        creators: Result<Vec<String>, String>,
        license_list_version: Result<Option<String>, String>,
    }
    impl Default for Spdx23CreationInfo {
        fn default() -> Self {
            Self {
                comment: Ok(Default::default()),
                created: Err("no value supplied for created".to_string()),
                creators: Err("no value supplied for creators".to_string()),
                license_list_version: Ok(Default::default()),
            }
        }
    }
    impl Spdx23CreationInfo {
        pub fn comment<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .comment = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for comment: {}", e)
                });
            self
        }
        pub fn created<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .created = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for created: {}", e)
                });
            self
        }
        pub fn creators<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .creators = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for creators: {}", e)
                });
            self
        }
        pub fn license_list_version<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .license_list_version = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for license_list_version: {}", e
                    )
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx23CreationInfo> for super::Spdx23CreationInfo {
        type Error = String;
        fn try_from(value: Spdx23CreationInfo) -> Result<Self, String> {
            Ok(Self {
                comment: value.comment?,
                created: value.created?,
                creators: value.creators?,
                license_list_version: value.license_list_version?,
            })
        }
    }
    impl From<super::Spdx23CreationInfo> for Spdx23CreationInfo {
        fn from(value: super::Spdx23CreationInfo) -> Self {
            Self {
                comment: Ok(value.comment),
                created: Ok(value.created),
                creators: Ok(value.creators),
                license_list_version: Ok(value.license_list_version),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx23ExternalDocumentRefsItem {
        checksum: Result<super::Spdx23ExternalDocumentRefsItemChecksum, String>,
        external_document_id: Result<String, String>,
        spdx_document: Result<String, String>,
    }
    impl Default for Spdx23ExternalDocumentRefsItem {
        fn default() -> Self {
            Self {
                checksum: Err("no value supplied for checksum".to_string()),
                external_document_id: Err(
                    "no value supplied for external_document_id".to_string(),
                ),
                spdx_document: Err("no value supplied for spdx_document".to_string()),
            }
        }
    }
    impl Spdx23ExternalDocumentRefsItem {
        pub fn checksum<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<super::Spdx23ExternalDocumentRefsItemChecksum>,
            T::Error: std::fmt::Display,
        {
            self
                .checksum = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for checksum: {}", e)
                });
            self
        }
        pub fn external_document_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .external_document_id = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for external_document_id: {}", e
                    )
                });
            self
        }
        pub fn spdx_document<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .spdx_document = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for spdx_document: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx23ExternalDocumentRefsItem>
    for super::Spdx23ExternalDocumentRefsItem {
        type Error = String;
        fn try_from(value: Spdx23ExternalDocumentRefsItem) -> Result<Self, String> {
            Ok(Self {
                checksum: value.checksum?,
                external_document_id: value.external_document_id?,
                spdx_document: value.spdx_document?,
            })
        }
    }
    impl From<super::Spdx23ExternalDocumentRefsItem> for Spdx23ExternalDocumentRefsItem {
        fn from(value: super::Spdx23ExternalDocumentRefsItem) -> Self {
            Self {
                checksum: Ok(value.checksum),
                external_document_id: Ok(value.external_document_id),
                spdx_document: Ok(value.spdx_document),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx23ExternalDocumentRefsItemChecksum {
        algorithm: Result<
            super::Spdx23ExternalDocumentRefsItemChecksumAlgorithm,
            String,
        >,
        checksum_value: Result<String, String>,
    }
    impl Default for Spdx23ExternalDocumentRefsItemChecksum {
        fn default() -> Self {
            Self {
                algorithm: Err("no value supplied for algorithm".to_string()),
                checksum_value: Err("no value supplied for checksum_value".to_string()),
            }
        }
    }
    impl Spdx23ExternalDocumentRefsItemChecksum {
        pub fn algorithm<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                super::Spdx23ExternalDocumentRefsItemChecksumAlgorithm,
            >,
            T::Error: std::fmt::Display,
        {
            self
                .algorithm = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for algorithm: {}", e)
                });
            self
        }
        pub fn checksum_value<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .checksum_value = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for checksum_value: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx23ExternalDocumentRefsItemChecksum>
    for super::Spdx23ExternalDocumentRefsItemChecksum {
        type Error = String;
        fn try_from(
            value: Spdx23ExternalDocumentRefsItemChecksum,
        ) -> Result<Self, String> {
            Ok(Self {
                algorithm: value.algorithm?,
                checksum_value: value.checksum_value?,
            })
        }
    }
    impl From<super::Spdx23ExternalDocumentRefsItemChecksum>
    for Spdx23ExternalDocumentRefsItemChecksum {
        fn from(value: super::Spdx23ExternalDocumentRefsItemChecksum) -> Self {
            Self {
                algorithm: Ok(value.algorithm),
                checksum_value: Ok(value.checksum_value),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx23FilesItem {
        annotations: Result<Vec<super::Spdx23FilesItemAnnotationsItem>, String>,
        artifact_ofs: Result<
            Vec<std::collections::HashMap<String, serde_json::Value>>,
            String,
        >,
        attribution_texts: Result<Vec<String>, String>,
        checksums: Result<Vec<super::Spdx23FilesItemChecksumsItem>, String>,
        comment: Result<Option<String>, String>,
        copyright_text: Result<Option<String>, String>,
        file_contributors: Result<Vec<String>, String>,
        file_dependencies: Result<Vec<String>, String>,
        file_name: Result<String, String>,
        file_types: Result<Vec<super::Spdx23FilesItemFileTypesItem>, String>,
        license_comments: Result<Option<String>, String>,
        license_concluded: Result<Option<String>, String>,
        license_info_in_files: Result<Vec<String>, String>,
        notice_text: Result<Option<String>, String>,
        spdxid: Result<String, String>,
    }
    impl Default for Spdx23FilesItem {
        fn default() -> Self {
            Self {
                annotations: Ok(Default::default()),
                artifact_ofs: Ok(Default::default()),
                attribution_texts: Ok(Default::default()),
                checksums: Err("no value supplied for checksums".to_string()),
                comment: Ok(Default::default()),
                copyright_text: Ok(Default::default()),
                file_contributors: Ok(Default::default()),
                file_dependencies: Ok(Default::default()),
                file_name: Err("no value supplied for file_name".to_string()),
                file_types: Ok(Default::default()),
                license_comments: Ok(Default::default()),
                license_concluded: Ok(Default::default()),
                license_info_in_files: Ok(Default::default()),
                notice_text: Ok(Default::default()),
                spdxid: Err("no value supplied for spdxid".to_string()),
            }
        }
    }
    impl Spdx23FilesItem {
        pub fn annotations<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Spdx23FilesItemAnnotationsItem>>,
            T::Error: std::fmt::Display,
        {
            self
                .annotations = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for annotations: {}", e)
                });
            self
        }
        pub fn artifact_ofs<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Vec<std::collections::HashMap<String, serde_json::Value>>,
            >,
            T::Error: std::fmt::Display,
        {
            self
                .artifact_ofs = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for artifact_ofs: {}", e)
                });
            self
        }
        pub fn attribution_texts<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .attribution_texts = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for attribution_texts: {}", e
                    )
                });
            self
        }
        pub fn checksums<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Spdx23FilesItemChecksumsItem>>,
            T::Error: std::fmt::Display,
        {
            self
                .checksums = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for checksums: {}", e)
                });
            self
        }
        pub fn comment<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .comment = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for comment: {}", e)
                });
            self
        }
        pub fn copyright_text<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .copyright_text = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for copyright_text: {}", e)
                });
            self
        }
        pub fn file_contributors<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .file_contributors = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for file_contributors: {}", e
                    )
                });
            self
        }
        pub fn file_dependencies<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .file_dependencies = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for file_dependencies: {}", e
                    )
                });
            self
        }
        pub fn file_name<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .file_name = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for file_name: {}", e)
                });
            self
        }
        pub fn file_types<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Spdx23FilesItemFileTypesItem>>,
            T::Error: std::fmt::Display,
        {
            self
                .file_types = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for file_types: {}", e)
                });
            self
        }
        pub fn license_comments<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .license_comments = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for license_comments: {}", e
                    )
                });
            self
        }
        pub fn license_concluded<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .license_concluded = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for license_concluded: {}", e
                    )
                });
            self
        }
        pub fn license_info_in_files<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .license_info_in_files = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for license_info_in_files: {}",
                        e
                    )
                });
            self
        }
        pub fn notice_text<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .notice_text = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for notice_text: {}", e)
                });
            self
        }
        pub fn spdxid<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .spdxid = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for spdxid: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx23FilesItem> for super::Spdx23FilesItem {
        type Error = String;
        fn try_from(value: Spdx23FilesItem) -> Result<Self, String> {
            Ok(Self {
                annotations: value.annotations?,
                artifact_ofs: value.artifact_ofs?,
                attribution_texts: value.attribution_texts?,
                checksums: value.checksums?,
                comment: value.comment?,
                copyright_text: value.copyright_text?,
                file_contributors: value.file_contributors?,
                file_dependencies: value.file_dependencies?,
                file_name: value.file_name?,
                file_types: value.file_types?,
                license_comments: value.license_comments?,
                license_concluded: value.license_concluded?,
                license_info_in_files: value.license_info_in_files?,
                notice_text: value.notice_text?,
                spdxid: value.spdxid?,
            })
        }
    }
    impl From<super::Spdx23FilesItem> for Spdx23FilesItem {
        fn from(value: super::Spdx23FilesItem) -> Self {
            Self {
                annotations: Ok(value.annotations),
                artifact_ofs: Ok(value.artifact_ofs),
                attribution_texts: Ok(value.attribution_texts),
                checksums: Ok(value.checksums),
                comment: Ok(value.comment),
                copyright_text: Ok(value.copyright_text),
                file_contributors: Ok(value.file_contributors),
                file_dependencies: Ok(value.file_dependencies),
                file_name: Ok(value.file_name),
                file_types: Ok(value.file_types),
                license_comments: Ok(value.license_comments),
                license_concluded: Ok(value.license_concluded),
                license_info_in_files: Ok(value.license_info_in_files),
                notice_text: Ok(value.notice_text),
                spdxid: Ok(value.spdxid),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx23FilesItemAnnotationsItem {
        annotation_date: Result<String, String>,
        annotation_type: Result<
            super::Spdx23FilesItemAnnotationsItemAnnotationType,
            String,
        >,
        annotator: Result<String, String>,
        comment: Result<String, String>,
    }
    impl Default for Spdx23FilesItemAnnotationsItem {
        fn default() -> Self {
            Self {
                annotation_date: Err(
                    "no value supplied for annotation_date".to_string(),
                ),
                annotation_type: Err(
                    "no value supplied for annotation_type".to_string(),
                ),
                annotator: Err("no value supplied for annotator".to_string()),
                comment: Err("no value supplied for comment".to_string()),
            }
        }
    }
    impl Spdx23FilesItemAnnotationsItem {
        pub fn annotation_date<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .annotation_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for annotation_date: {}", e)
                });
            self
        }
        pub fn annotation_type<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                super::Spdx23FilesItemAnnotationsItemAnnotationType,
            >,
            T::Error: std::fmt::Display,
        {
            self
                .annotation_type = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for annotation_type: {}", e)
                });
            self
        }
        pub fn annotator<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .annotator = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for annotator: {}", e)
                });
            self
        }
        pub fn comment<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .comment = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for comment: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx23FilesItemAnnotationsItem>
    for super::Spdx23FilesItemAnnotationsItem {
        type Error = String;
        fn try_from(value: Spdx23FilesItemAnnotationsItem) -> Result<Self, String> {
            Ok(Self {
                annotation_date: value.annotation_date?,
                annotation_type: value.annotation_type?,
                annotator: value.annotator?,
                comment: value.comment?,
            })
        }
    }
    impl From<super::Spdx23FilesItemAnnotationsItem> for Spdx23FilesItemAnnotationsItem {
        fn from(value: super::Spdx23FilesItemAnnotationsItem) -> Self {
            Self {
                annotation_date: Ok(value.annotation_date),
                annotation_type: Ok(value.annotation_type),
                annotator: Ok(value.annotator),
                comment: Ok(value.comment),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx23FilesItemChecksumsItem {
        algorithm: Result<super::Spdx23FilesItemChecksumsItemAlgorithm, String>,
        checksum_value: Result<String, String>,
    }
    impl Default for Spdx23FilesItemChecksumsItem {
        fn default() -> Self {
            Self {
                algorithm: Err("no value supplied for algorithm".to_string()),
                checksum_value: Err("no value supplied for checksum_value".to_string()),
            }
        }
    }
    impl Spdx23FilesItemChecksumsItem {
        pub fn algorithm<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<super::Spdx23FilesItemChecksumsItemAlgorithm>,
            T::Error: std::fmt::Display,
        {
            self
                .algorithm = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for algorithm: {}", e)
                });
            self
        }
        pub fn checksum_value<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .checksum_value = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for checksum_value: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx23FilesItemChecksumsItem>
    for super::Spdx23FilesItemChecksumsItem {
        type Error = String;
        fn try_from(value: Spdx23FilesItemChecksumsItem) -> Result<Self, String> {
            Ok(Self {
                algorithm: value.algorithm?,
                checksum_value: value.checksum_value?,
            })
        }
    }
    impl From<super::Spdx23FilesItemChecksumsItem> for Spdx23FilesItemChecksumsItem {
        fn from(value: super::Spdx23FilesItemChecksumsItem) -> Self {
            Self {
                algorithm: Ok(value.algorithm),
                checksum_value: Ok(value.checksum_value),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx23HasExtractedLicensingInfosItem {
        comment: Result<Option<String>, String>,
        cross_refs: Result<
            Vec<super::Spdx23HasExtractedLicensingInfosItemCrossRefsItem>,
            String,
        >,
        extracted_text: Result<String, String>,
        license_id: Result<String, String>,
        name: Result<Option<String>, String>,
        see_alsos: Result<Vec<String>, String>,
    }
    impl Default for Spdx23HasExtractedLicensingInfosItem {
        fn default() -> Self {
            Self {
                comment: Ok(Default::default()),
                cross_refs: Ok(Default::default()),
                extracted_text: Err("no value supplied for extracted_text".to_string()),
                license_id: Err("no value supplied for license_id".to_string()),
                name: Ok(Default::default()),
                see_alsos: Ok(Default::default()),
            }
        }
    }
    impl Spdx23HasExtractedLicensingInfosItem {
        pub fn comment<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .comment = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for comment: {}", e)
                });
            self
        }
        pub fn cross_refs<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Vec<super::Spdx23HasExtractedLicensingInfosItemCrossRefsItem>,
            >,
            T::Error: std::fmt::Display,
        {
            self
                .cross_refs = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for cross_refs: {}", e)
                });
            self
        }
        pub fn extracted_text<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .extracted_text = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for extracted_text: {}", e)
                });
            self
        }
        pub fn license_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .license_id = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for license_id: {}", e)
                });
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn see_alsos<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .see_alsos = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for see_alsos: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx23HasExtractedLicensingInfosItem>
    for super::Spdx23HasExtractedLicensingInfosItem {
        type Error = String;
        fn try_from(
            value: Spdx23HasExtractedLicensingInfosItem,
        ) -> Result<Self, String> {
            Ok(Self {
                comment: value.comment?,
                cross_refs: value.cross_refs?,
                extracted_text: value.extracted_text?,
                license_id: value.license_id?,
                name: value.name?,
                see_alsos: value.see_alsos?,
            })
        }
    }
    impl From<super::Spdx23HasExtractedLicensingInfosItem>
    for Spdx23HasExtractedLicensingInfosItem {
        fn from(value: super::Spdx23HasExtractedLicensingInfosItem) -> Self {
            Self {
                comment: Ok(value.comment),
                cross_refs: Ok(value.cross_refs),
                extracted_text: Ok(value.extracted_text),
                license_id: Ok(value.license_id),
                name: Ok(value.name),
                see_alsos: Ok(value.see_alsos),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx23HasExtractedLicensingInfosItemCrossRefsItem {
        is_live: Result<Option<bool>, String>,
        is_valid: Result<Option<bool>, String>,
        is_way_back_link: Result<Option<bool>, String>,
        match_: Result<Option<String>, String>,
        order: Result<Option<i64>, String>,
        timestamp: Result<Option<String>, String>,
        url: Result<String, String>,
    }
    impl Default for Spdx23HasExtractedLicensingInfosItemCrossRefsItem {
        fn default() -> Self {
            Self {
                is_live: Ok(Default::default()),
                is_valid: Ok(Default::default()),
                is_way_back_link: Ok(Default::default()),
                match_: Ok(Default::default()),
                order: Ok(Default::default()),
                timestamp: Ok(Default::default()),
                url: Err("no value supplied for url".to_string()),
            }
        }
    }
    impl Spdx23HasExtractedLicensingInfosItemCrossRefsItem {
        pub fn is_live<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<bool>>,
            T::Error: std::fmt::Display,
        {
            self
                .is_live = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_live: {}", e)
                });
            self
        }
        pub fn is_valid<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<bool>>,
            T::Error: std::fmt::Display,
        {
            self
                .is_valid = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_valid: {}", e)
                });
            self
        }
        pub fn is_way_back_link<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<bool>>,
            T::Error: std::fmt::Display,
        {
            self
                .is_way_back_link = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for is_way_back_link: {}", e
                    )
                });
            self
        }
        pub fn match_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .match_ = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for match_: {}", e)
                });
            self
        }
        pub fn order<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self
                .order = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for order: {}", e)
                });
            self
        }
        pub fn timestamp<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .timestamp = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for timestamp: {}", e)
                });
            self
        }
        pub fn url<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .url = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for url: {}", e));
            self
        }
    }
    impl std::convert::TryFrom<Spdx23HasExtractedLicensingInfosItemCrossRefsItem>
    for super::Spdx23HasExtractedLicensingInfosItemCrossRefsItem {
        type Error = String;
        fn try_from(
            value: Spdx23HasExtractedLicensingInfosItemCrossRefsItem,
        ) -> Result<Self, String> {
            Ok(Self {
                is_live: value.is_live?,
                is_valid: value.is_valid?,
                is_way_back_link: value.is_way_back_link?,
                match_: value.match_?,
                order: value.order?,
                timestamp: value.timestamp?,
                url: value.url?,
            })
        }
    }
    impl From<super::Spdx23HasExtractedLicensingInfosItemCrossRefsItem>
    for Spdx23HasExtractedLicensingInfosItemCrossRefsItem {
        fn from(
            value: super::Spdx23HasExtractedLicensingInfosItemCrossRefsItem,
        ) -> Self {
            Self {
                is_live: Ok(value.is_live),
                is_valid: Ok(value.is_valid),
                is_way_back_link: Ok(value.is_way_back_link),
                match_: Ok(value.match_),
                order: Ok(value.order),
                timestamp: Ok(value.timestamp),
                url: Ok(value.url),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx23PackagesItem {
        annotations: Result<Vec<super::Spdx23PackagesItemAnnotationsItem>, String>,
        attribution_texts: Result<Vec<String>, String>,
        built_date: Result<Option<String>, String>,
        checksums: Result<Vec<super::Spdx23PackagesItemChecksumsItem>, String>,
        comment: Result<Option<String>, String>,
        copyright_text: Result<Option<String>, String>,
        description: Result<Option<String>, String>,
        download_location: Result<String, String>,
        external_refs: Result<Vec<super::Spdx23PackagesItemExternalRefsItem>, String>,
        files_analyzed: Result<Option<bool>, String>,
        has_files: Result<Vec<String>, String>,
        homepage: Result<Option<String>, String>,
        license_comments: Result<Option<String>, String>,
        license_concluded: Result<Option<String>, String>,
        license_declared: Result<Option<String>, String>,
        license_info_from_files: Result<Vec<String>, String>,
        name: Result<String, String>,
        originator: Result<Option<String>, String>,
        package_file_name: Result<Option<String>, String>,
        package_verification_code: Result<
            Option<super::Spdx23PackagesItemPackageVerificationCode>,
            String,
        >,
        primary_package_purpose: Result<
            Option<super::Spdx23PackagesItemPrimaryPackagePurpose>,
            String,
        >,
        release_date: Result<Option<String>, String>,
        source_info: Result<Option<String>, String>,
        spdxid: Result<String, String>,
        summary: Result<Option<String>, String>,
        supplier: Result<Option<String>, String>,
        valid_until_date: Result<Option<String>, String>,
        version_info: Result<Option<String>, String>,
    }
    impl Default for Spdx23PackagesItem {
        fn default() -> Self {
            Self {
                annotations: Ok(Default::default()),
                attribution_texts: Ok(Default::default()),
                built_date: Ok(Default::default()),
                checksums: Ok(Default::default()),
                comment: Ok(Default::default()),
                copyright_text: Ok(Default::default()),
                description: Ok(Default::default()),
                download_location: Err(
                    "no value supplied for download_location".to_string(),
                ),
                external_refs: Ok(Default::default()),
                files_analyzed: Ok(Default::default()),
                has_files: Ok(Default::default()),
                homepage: Ok(Default::default()),
                license_comments: Ok(Default::default()),
                license_concluded: Ok(Default::default()),
                license_declared: Ok(Default::default()),
                license_info_from_files: Ok(Default::default()),
                name: Err("no value supplied for name".to_string()),
                originator: Ok(Default::default()),
                package_file_name: Ok(Default::default()),
                package_verification_code: Ok(Default::default()),
                primary_package_purpose: Ok(Default::default()),
                release_date: Ok(Default::default()),
                source_info: Ok(Default::default()),
                spdxid: Err("no value supplied for spdxid".to_string()),
                summary: Ok(Default::default()),
                supplier: Ok(Default::default()),
                valid_until_date: Ok(Default::default()),
                version_info: Ok(Default::default()),
            }
        }
    }
    impl Spdx23PackagesItem {
        pub fn annotations<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Spdx23PackagesItemAnnotationsItem>>,
            T::Error: std::fmt::Display,
        {
            self
                .annotations = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for annotations: {}", e)
                });
            self
        }
        pub fn attribution_texts<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .attribution_texts = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for attribution_texts: {}", e
                    )
                });
            self
        }
        pub fn built_date<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .built_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for built_date: {}", e)
                });
            self
        }
        pub fn checksums<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Spdx23PackagesItemChecksumsItem>>,
            T::Error: std::fmt::Display,
        {
            self
                .checksums = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for checksums: {}", e)
                });
            self
        }
        pub fn comment<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .comment = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for comment: {}", e)
                });
            self
        }
        pub fn copyright_text<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .copyright_text = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for copyright_text: {}", e)
                });
            self
        }
        pub fn description<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .description = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for description: {}", e)
                });
            self
        }
        pub fn download_location<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .download_location = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for download_location: {}", e
                    )
                });
            self
        }
        pub fn external_refs<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Spdx23PackagesItemExternalRefsItem>>,
            T::Error: std::fmt::Display,
        {
            self
                .external_refs = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for external_refs: {}", e)
                });
            self
        }
        pub fn files_analyzed<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<bool>>,
            T::Error: std::fmt::Display,
        {
            self
                .files_analyzed = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for files_analyzed: {}", e)
                });
            self
        }
        pub fn has_files<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .has_files = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for has_files: {}", e)
                });
            self
        }
        pub fn homepage<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .homepage = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for homepage: {}", e)
                });
            self
        }
        pub fn license_comments<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .license_comments = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for license_comments: {}", e
                    )
                });
            self
        }
        pub fn license_concluded<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .license_concluded = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for license_concluded: {}", e
                    )
                });
            self
        }
        pub fn license_declared<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .license_declared = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for license_declared: {}", e
                    )
                });
            self
        }
        pub fn license_info_from_files<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .license_info_from_files = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for license_info_from_files: {}",
                        e
                    )
                });
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn originator<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .originator = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for originator: {}", e)
                });
            self
        }
        pub fn package_file_name<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .package_file_name = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for package_file_name: {}", e
                    )
                });
            self
        }
        pub fn package_verification_code<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Option<super::Spdx23PackagesItemPackageVerificationCode>,
            >,
            T::Error: std::fmt::Display,
        {
            self
                .package_verification_code = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for package_verification_code: {}",
                        e
                    )
                });
            self
        }
        pub fn primary_package_purpose<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Option<super::Spdx23PackagesItemPrimaryPackagePurpose>,
            >,
            T::Error: std::fmt::Display,
        {
            self
                .primary_package_purpose = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for primary_package_purpose: {}",
                        e
                    )
                });
            self
        }
        pub fn release_date<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .release_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for release_date: {}", e)
                });
            self
        }
        pub fn source_info<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .source_info = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for source_info: {}", e)
                });
            self
        }
        pub fn spdxid<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .spdxid = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for spdxid: {}", e)
                });
            self
        }
        pub fn summary<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .summary = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for summary: {}", e)
                });
            self
        }
        pub fn supplier<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .supplier = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for supplier: {}", e)
                });
            self
        }
        pub fn valid_until_date<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .valid_until_date = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for valid_until_date: {}", e
                    )
                });
            self
        }
        pub fn version_info<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .version_info = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for version_info: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx23PackagesItem> for super::Spdx23PackagesItem {
        type Error = String;
        fn try_from(value: Spdx23PackagesItem) -> Result<Self, String> {
            Ok(Self {
                annotations: value.annotations?,
                attribution_texts: value.attribution_texts?,
                built_date: value.built_date?,
                checksums: value.checksums?,
                comment: value.comment?,
                copyright_text: value.copyright_text?,
                description: value.description?,
                download_location: value.download_location?,
                external_refs: value.external_refs?,
                files_analyzed: value.files_analyzed?,
                has_files: value.has_files?,
                homepage: value.homepage?,
                license_comments: value.license_comments?,
                license_concluded: value.license_concluded?,
                license_declared: value.license_declared?,
                license_info_from_files: value.license_info_from_files?,
                name: value.name?,
                originator: value.originator?,
                package_file_name: value.package_file_name?,
                package_verification_code: value.package_verification_code?,
                primary_package_purpose: value.primary_package_purpose?,
                release_date: value.release_date?,
                source_info: value.source_info?,
                spdxid: value.spdxid?,
                summary: value.summary?,
                supplier: value.supplier?,
                valid_until_date: value.valid_until_date?,
                version_info: value.version_info?,
            })
        }
    }
    impl From<super::Spdx23PackagesItem> for Spdx23PackagesItem {
        fn from(value: super::Spdx23PackagesItem) -> Self {
            Self {
                annotations: Ok(value.annotations),
                attribution_texts: Ok(value.attribution_texts),
                built_date: Ok(value.built_date),
                checksums: Ok(value.checksums),
                comment: Ok(value.comment),
                copyright_text: Ok(value.copyright_text),
                description: Ok(value.description),
                download_location: Ok(value.download_location),
                external_refs: Ok(value.external_refs),
                files_analyzed: Ok(value.files_analyzed),
                has_files: Ok(value.has_files),
                homepage: Ok(value.homepage),
                license_comments: Ok(value.license_comments),
                license_concluded: Ok(value.license_concluded),
                license_declared: Ok(value.license_declared),
                license_info_from_files: Ok(value.license_info_from_files),
                name: Ok(value.name),
                originator: Ok(value.originator),
                package_file_name: Ok(value.package_file_name),
                package_verification_code: Ok(value.package_verification_code),
                primary_package_purpose: Ok(value.primary_package_purpose),
                release_date: Ok(value.release_date),
                source_info: Ok(value.source_info),
                spdxid: Ok(value.spdxid),
                summary: Ok(value.summary),
                supplier: Ok(value.supplier),
                valid_until_date: Ok(value.valid_until_date),
                version_info: Ok(value.version_info),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx23PackagesItemAnnotationsItem {
        annotation_date: Result<String, String>,
        annotation_type: Result<
            super::Spdx23PackagesItemAnnotationsItemAnnotationType,
            String,
        >,
        annotator: Result<String, String>,
        comment: Result<String, String>,
    }
    impl Default for Spdx23PackagesItemAnnotationsItem {
        fn default() -> Self {
            Self {
                annotation_date: Err(
                    "no value supplied for annotation_date".to_string(),
                ),
                annotation_type: Err(
                    "no value supplied for annotation_type".to_string(),
                ),
                annotator: Err("no value supplied for annotator".to_string()),
                comment: Err("no value supplied for comment".to_string()),
            }
        }
    }
    impl Spdx23PackagesItemAnnotationsItem {
        pub fn annotation_date<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .annotation_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for annotation_date: {}", e)
                });
            self
        }
        pub fn annotation_type<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                super::Spdx23PackagesItemAnnotationsItemAnnotationType,
            >,
            T::Error: std::fmt::Display,
        {
            self
                .annotation_type = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for annotation_type: {}", e)
                });
            self
        }
        pub fn annotator<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .annotator = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for annotator: {}", e)
                });
            self
        }
        pub fn comment<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .comment = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for comment: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx23PackagesItemAnnotationsItem>
    for super::Spdx23PackagesItemAnnotationsItem {
        type Error = String;
        fn try_from(value: Spdx23PackagesItemAnnotationsItem) -> Result<Self, String> {
            Ok(Self {
                annotation_date: value.annotation_date?,
                annotation_type: value.annotation_type?,
                annotator: value.annotator?,
                comment: value.comment?,
            })
        }
    }
    impl From<super::Spdx23PackagesItemAnnotationsItem>
    for Spdx23PackagesItemAnnotationsItem {
        fn from(value: super::Spdx23PackagesItemAnnotationsItem) -> Self {
            Self {
                annotation_date: Ok(value.annotation_date),
                annotation_type: Ok(value.annotation_type),
                annotator: Ok(value.annotator),
                comment: Ok(value.comment),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx23PackagesItemChecksumsItem {
        algorithm: Result<super::Spdx23PackagesItemChecksumsItemAlgorithm, String>,
        checksum_value: Result<String, String>,
    }
    impl Default for Spdx23PackagesItemChecksumsItem {
        fn default() -> Self {
            Self {
                algorithm: Err("no value supplied for algorithm".to_string()),
                checksum_value: Err("no value supplied for checksum_value".to_string()),
            }
        }
    }
    impl Spdx23PackagesItemChecksumsItem {
        pub fn algorithm<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<super::Spdx23PackagesItemChecksumsItemAlgorithm>,
            T::Error: std::fmt::Display,
        {
            self
                .algorithm = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for algorithm: {}", e)
                });
            self
        }
        pub fn checksum_value<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .checksum_value = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for checksum_value: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx23PackagesItemChecksumsItem>
    for super::Spdx23PackagesItemChecksumsItem {
        type Error = String;
        fn try_from(value: Spdx23PackagesItemChecksumsItem) -> Result<Self, String> {
            Ok(Self {
                algorithm: value.algorithm?,
                checksum_value: value.checksum_value?,
            })
        }
    }
    impl From<super::Spdx23PackagesItemChecksumsItem>
    for Spdx23PackagesItemChecksumsItem {
        fn from(value: super::Spdx23PackagesItemChecksumsItem) -> Self {
            Self {
                algorithm: Ok(value.algorithm),
                checksum_value: Ok(value.checksum_value),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx23PackagesItemExternalRefsItem {
        comment: Result<Option<String>, String>,
        reference_category: Result<
            super::Spdx23PackagesItemExternalRefsItemReferenceCategory,
            String,
        >,
        reference_locator: Result<String, String>,
        reference_type: Result<String, String>,
    }
    impl Default for Spdx23PackagesItemExternalRefsItem {
        fn default() -> Self {
            Self {
                comment: Ok(Default::default()),
                reference_category: Err(
                    "no value supplied for reference_category".to_string(),
                ),
                reference_locator: Err(
                    "no value supplied for reference_locator".to_string(),
                ),
                reference_type: Err("no value supplied for reference_type".to_string()),
            }
        }
    }
    impl Spdx23PackagesItemExternalRefsItem {
        pub fn comment<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .comment = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for comment: {}", e)
                });
            self
        }
        pub fn reference_category<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                super::Spdx23PackagesItemExternalRefsItemReferenceCategory,
            >,
            T::Error: std::fmt::Display,
        {
            self
                .reference_category = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for reference_category: {}", e
                    )
                });
            self
        }
        pub fn reference_locator<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .reference_locator = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for reference_locator: {}", e
                    )
                });
            self
        }
        pub fn reference_type<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .reference_type = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for reference_type: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx23PackagesItemExternalRefsItem>
    for super::Spdx23PackagesItemExternalRefsItem {
        type Error = String;
        fn try_from(value: Spdx23PackagesItemExternalRefsItem) -> Result<Self, String> {
            Ok(Self {
                comment: value.comment?,
                reference_category: value.reference_category?,
                reference_locator: value.reference_locator?,
                reference_type: value.reference_type?,
            })
        }
    }
    impl From<super::Spdx23PackagesItemExternalRefsItem>
    for Spdx23PackagesItemExternalRefsItem {
        fn from(value: super::Spdx23PackagesItemExternalRefsItem) -> Self {
            Self {
                comment: Ok(value.comment),
                reference_category: Ok(value.reference_category),
                reference_locator: Ok(value.reference_locator),
                reference_type: Ok(value.reference_type),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx23PackagesItemPackageVerificationCode {
        package_verification_code_excluded_files: Result<Vec<String>, String>,
        package_verification_code_value: Result<String, String>,
    }
    impl Default for Spdx23PackagesItemPackageVerificationCode {
        fn default() -> Self {
            Self {
                package_verification_code_excluded_files: Ok(Default::default()),
                package_verification_code_value: Err(
                    "no value supplied for package_verification_code_value".to_string(),
                ),
            }
        }
    }
    impl Spdx23PackagesItemPackageVerificationCode {
        pub fn package_verification_code_excluded_files<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .package_verification_code_excluded_files = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for package_verification_code_excluded_files: {}",
                        e
                    )
                });
            self
        }
        pub fn package_verification_code_value<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .package_verification_code_value = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for package_verification_code_value: {}",
                        e
                    )
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx23PackagesItemPackageVerificationCode>
    for super::Spdx23PackagesItemPackageVerificationCode {
        type Error = String;
        fn try_from(
            value: Spdx23PackagesItemPackageVerificationCode,
        ) -> Result<Self, String> {
            Ok(Self {
                package_verification_code_excluded_files: value
                    .package_verification_code_excluded_files?,
                package_verification_code_value: value.package_verification_code_value?,
            })
        }
    }
    impl From<super::Spdx23PackagesItemPackageVerificationCode>
    for Spdx23PackagesItemPackageVerificationCode {
        fn from(value: super::Spdx23PackagesItemPackageVerificationCode) -> Self {
            Self {
                package_verification_code_excluded_files: Ok(
                    value.package_verification_code_excluded_files,
                ),
                package_verification_code_value: Ok(
                    value.package_verification_code_value,
                ),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx23RelationshipsItem {
        comment: Result<Option<String>, String>,
        related_spdx_element: Result<String, String>,
        relationship_type: Result<
            super::Spdx23RelationshipsItemRelationshipType,
            String,
        >,
        spdx_element_id: Result<String, String>,
    }
    impl Default for Spdx23RelationshipsItem {
        fn default() -> Self {
            Self {
                comment: Ok(Default::default()),
                related_spdx_element: Err(
                    "no value supplied for related_spdx_element".to_string(),
                ),
                relationship_type: Err(
                    "no value supplied for relationship_type".to_string(),
                ),
                spdx_element_id: Err("no value supplied for spdx_element_id".to_string()),
            }
        }
    }
    impl Spdx23RelationshipsItem {
        pub fn comment<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .comment = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for comment: {}", e)
                });
            self
        }
        pub fn related_spdx_element<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .related_spdx_element = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for related_spdx_element: {}", e
                    )
                });
            self
        }
        pub fn relationship_type<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<super::Spdx23RelationshipsItemRelationshipType>,
            T::Error: std::fmt::Display,
        {
            self
                .relationship_type = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for relationship_type: {}", e
                    )
                });
            self
        }
        pub fn spdx_element_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .spdx_element_id = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for spdx_element_id: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx23RelationshipsItem>
    for super::Spdx23RelationshipsItem {
        type Error = String;
        fn try_from(value: Spdx23RelationshipsItem) -> Result<Self, String> {
            Ok(Self {
                comment: value.comment?,
                related_spdx_element: value.related_spdx_element?,
                relationship_type: value.relationship_type?,
                spdx_element_id: value.spdx_element_id?,
            })
        }
    }
    impl From<super::Spdx23RelationshipsItem> for Spdx23RelationshipsItem {
        fn from(value: super::Spdx23RelationshipsItem) -> Self {
            Self {
                comment: Ok(value.comment),
                related_spdx_element: Ok(value.related_spdx_element),
                relationship_type: Ok(value.relationship_type),
                spdx_element_id: Ok(value.spdx_element_id),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx23ReviewedsItem {
        comment: Result<Option<String>, String>,
        review_date: Result<String, String>,
        reviewer: Result<Option<String>, String>,
    }
    impl Default for Spdx23ReviewedsItem {
        fn default() -> Self {
            Self {
                comment: Ok(Default::default()),
                review_date: Err("no value supplied for review_date".to_string()),
                reviewer: Ok(Default::default()),
            }
        }
    }
    impl Spdx23ReviewedsItem {
        pub fn comment<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .comment = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for comment: {}", e)
                });
            self
        }
        pub fn review_date<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .review_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for review_date: {}", e)
                });
            self
        }
        pub fn reviewer<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .reviewer = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for reviewer: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx23ReviewedsItem> for super::Spdx23ReviewedsItem {
        type Error = String;
        fn try_from(value: Spdx23ReviewedsItem) -> Result<Self, String> {
            Ok(Self {
                comment: value.comment?,
                review_date: value.review_date?,
                reviewer: value.reviewer?,
            })
        }
    }
    impl From<super::Spdx23ReviewedsItem> for Spdx23ReviewedsItem {
        fn from(value: super::Spdx23ReviewedsItem) -> Self {
            Self {
                comment: Ok(value.comment),
                review_date: Ok(value.review_date),
                reviewer: Ok(value.reviewer),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx23SnippetsItem {
        annotations: Result<Vec<super::Spdx23SnippetsItemAnnotationsItem>, String>,
        attribution_texts: Result<Vec<String>, String>,
        comment: Result<Option<String>, String>,
        copyright_text: Result<Option<String>, String>,
        license_comments: Result<Option<String>, String>,
        license_concluded: Result<Option<String>, String>,
        license_info_in_snippets: Result<Vec<String>, String>,
        name: Result<String, String>,
        ranges: Result<Vec<super::Spdx23SnippetsItemRangesItem>, String>,
        snippet_from_file: Result<String, String>,
        spdxid: Result<String, String>,
    }
    impl Default for Spdx23SnippetsItem {
        fn default() -> Self {
            Self {
                annotations: Ok(Default::default()),
                attribution_texts: Ok(Default::default()),
                comment: Ok(Default::default()),
                copyright_text: Ok(Default::default()),
                license_comments: Ok(Default::default()),
                license_concluded: Ok(Default::default()),
                license_info_in_snippets: Ok(Default::default()),
                name: Err("no value supplied for name".to_string()),
                ranges: Err("no value supplied for ranges".to_string()),
                snippet_from_file: Err(
                    "no value supplied for snippet_from_file".to_string(),
                ),
                spdxid: Err("no value supplied for spdxid".to_string()),
            }
        }
    }
    impl Spdx23SnippetsItem {
        pub fn annotations<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Spdx23SnippetsItemAnnotationsItem>>,
            T::Error: std::fmt::Display,
        {
            self
                .annotations = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for annotations: {}", e)
                });
            self
        }
        pub fn attribution_texts<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .attribution_texts = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for attribution_texts: {}", e
                    )
                });
            self
        }
        pub fn comment<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .comment = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for comment: {}", e)
                });
            self
        }
        pub fn copyright_text<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .copyright_text = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for copyright_text: {}", e)
                });
            self
        }
        pub fn license_comments<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .license_comments = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for license_comments: {}", e
                    )
                });
            self
        }
        pub fn license_concluded<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .license_concluded = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for license_concluded: {}", e
                    )
                });
            self
        }
        pub fn license_info_in_snippets<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .license_info_in_snippets = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for license_info_in_snippets: {}",
                        e
                    )
                });
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn ranges<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Spdx23SnippetsItemRangesItem>>,
            T::Error: std::fmt::Display,
        {
            self
                .ranges = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for ranges: {}", e)
                });
            self
        }
        pub fn snippet_from_file<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .snippet_from_file = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for snippet_from_file: {}", e
                    )
                });
            self
        }
        pub fn spdxid<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .spdxid = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for spdxid: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx23SnippetsItem> for super::Spdx23SnippetsItem {
        type Error = String;
        fn try_from(value: Spdx23SnippetsItem) -> Result<Self, String> {
            Ok(Self {
                annotations: value.annotations?,
                attribution_texts: value.attribution_texts?,
                comment: value.comment?,
                copyright_text: value.copyright_text?,
                license_comments: value.license_comments?,
                license_concluded: value.license_concluded?,
                license_info_in_snippets: value.license_info_in_snippets?,
                name: value.name?,
                ranges: value.ranges?,
                snippet_from_file: value.snippet_from_file?,
                spdxid: value.spdxid?,
            })
        }
    }
    impl From<super::Spdx23SnippetsItem> for Spdx23SnippetsItem {
        fn from(value: super::Spdx23SnippetsItem) -> Self {
            Self {
                annotations: Ok(value.annotations),
                attribution_texts: Ok(value.attribution_texts),
                comment: Ok(value.comment),
                copyright_text: Ok(value.copyright_text),
                license_comments: Ok(value.license_comments),
                license_concluded: Ok(value.license_concluded),
                license_info_in_snippets: Ok(value.license_info_in_snippets),
                name: Ok(value.name),
                ranges: Ok(value.ranges),
                snippet_from_file: Ok(value.snippet_from_file),
                spdxid: Ok(value.spdxid),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx23SnippetsItemAnnotationsItem {
        annotation_date: Result<String, String>,
        annotation_type: Result<
            super::Spdx23SnippetsItemAnnotationsItemAnnotationType,
            String,
        >,
        annotator: Result<String, String>,
        comment: Result<String, String>,
    }
    impl Default for Spdx23SnippetsItemAnnotationsItem {
        fn default() -> Self {
            Self {
                annotation_date: Err(
                    "no value supplied for annotation_date".to_string(),
                ),
                annotation_type: Err(
                    "no value supplied for annotation_type".to_string(),
                ),
                annotator: Err("no value supplied for annotator".to_string()),
                comment: Err("no value supplied for comment".to_string()),
            }
        }
    }
    impl Spdx23SnippetsItemAnnotationsItem {
        pub fn annotation_date<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .annotation_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for annotation_date: {}", e)
                });
            self
        }
        pub fn annotation_type<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                super::Spdx23SnippetsItemAnnotationsItemAnnotationType,
            >,
            T::Error: std::fmt::Display,
        {
            self
                .annotation_type = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for annotation_type: {}", e)
                });
            self
        }
        pub fn annotator<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .annotator = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for annotator: {}", e)
                });
            self
        }
        pub fn comment<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .comment = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for comment: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx23SnippetsItemAnnotationsItem>
    for super::Spdx23SnippetsItemAnnotationsItem {
        type Error = String;
        fn try_from(value: Spdx23SnippetsItemAnnotationsItem) -> Result<Self, String> {
            Ok(Self {
                annotation_date: value.annotation_date?,
                annotation_type: value.annotation_type?,
                annotator: value.annotator?,
                comment: value.comment?,
            })
        }
    }
    impl From<super::Spdx23SnippetsItemAnnotationsItem>
    for Spdx23SnippetsItemAnnotationsItem {
        fn from(value: super::Spdx23SnippetsItemAnnotationsItem) -> Self {
            Self {
                annotation_date: Ok(value.annotation_date),
                annotation_type: Ok(value.annotation_type),
                annotator: Ok(value.annotator),
                comment: Ok(value.comment),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx23SnippetsItemRangesItem {
        end_pointer: Result<super::Spdx23SnippetsItemRangesItemEndPointer, String>,
        start_pointer: Result<super::Spdx23SnippetsItemRangesItemStartPointer, String>,
    }
    impl Default for Spdx23SnippetsItemRangesItem {
        fn default() -> Self {
            Self {
                end_pointer: Err("no value supplied for end_pointer".to_string()),
                start_pointer: Err("no value supplied for start_pointer".to_string()),
            }
        }
    }
    impl Spdx23SnippetsItemRangesItem {
        pub fn end_pointer<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<super::Spdx23SnippetsItemRangesItemEndPointer>,
            T::Error: std::fmt::Display,
        {
            self
                .end_pointer = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for end_pointer: {}", e)
                });
            self
        }
        pub fn start_pointer<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<super::Spdx23SnippetsItemRangesItemStartPointer>,
            T::Error: std::fmt::Display,
        {
            self
                .start_pointer = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for start_pointer: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx23SnippetsItemRangesItem>
    for super::Spdx23SnippetsItemRangesItem {
        type Error = String;
        fn try_from(value: Spdx23SnippetsItemRangesItem) -> Result<Self, String> {
            Ok(Self {
                end_pointer: value.end_pointer?,
                start_pointer: value.start_pointer?,
            })
        }
    }
    impl From<super::Spdx23SnippetsItemRangesItem> for Spdx23SnippetsItemRangesItem {
        fn from(value: super::Spdx23SnippetsItemRangesItem) -> Self {
            Self {
                end_pointer: Ok(value.end_pointer),
                start_pointer: Ok(value.start_pointer),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx23SnippetsItemRangesItemEndPointer {
        line_number: Result<Option<i64>, String>,
        offset: Result<Option<i64>, String>,
        reference: Result<String, String>,
    }
    impl Default for Spdx23SnippetsItemRangesItemEndPointer {
        fn default() -> Self {
            Self {
                line_number: Ok(Default::default()),
                offset: Ok(Default::default()),
                reference: Err("no value supplied for reference".to_string()),
            }
        }
    }
    impl Spdx23SnippetsItemRangesItemEndPointer {
        pub fn line_number<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self
                .line_number = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for line_number: {}", e)
                });
            self
        }
        pub fn offset<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self
                .offset = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for offset: {}", e)
                });
            self
        }
        pub fn reference<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .reference = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for reference: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx23SnippetsItemRangesItemEndPointer>
    for super::Spdx23SnippetsItemRangesItemEndPointer {
        type Error = String;
        fn try_from(
            value: Spdx23SnippetsItemRangesItemEndPointer,
        ) -> Result<Self, String> {
            Ok(Self {
                line_number: value.line_number?,
                offset: value.offset?,
                reference: value.reference?,
            })
        }
    }
    impl From<super::Spdx23SnippetsItemRangesItemEndPointer>
    for Spdx23SnippetsItemRangesItemEndPointer {
        fn from(value: super::Spdx23SnippetsItemRangesItemEndPointer) -> Self {
            Self {
                line_number: Ok(value.line_number),
                offset: Ok(value.offset),
                reference: Ok(value.reference),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx23SnippetsItemRangesItemStartPointer {
        line_number: Result<Option<i64>, String>,
        offset: Result<Option<i64>, String>,
        reference: Result<String, String>,
    }
    impl Default for Spdx23SnippetsItemRangesItemStartPointer {
        fn default() -> Self {
            Self {
                line_number: Ok(Default::default()),
                offset: Ok(Default::default()),
                reference: Err("no value supplied for reference".to_string()),
            }
        }
    }
    impl Spdx23SnippetsItemRangesItemStartPointer {
        pub fn line_number<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self
                .line_number = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for line_number: {}", e)
                });
            self
        }
        pub fn offset<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self
                .offset = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for offset: {}", e)
                });
            self
        }
        pub fn reference<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<String>,
            T::Error: std::fmt::Display,
        {
            self
                .reference = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for reference: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx23SnippetsItemRangesItemStartPointer>
    for super::Spdx23SnippetsItemRangesItemStartPointer {
        type Error = String;
        fn try_from(
            value: Spdx23SnippetsItemRangesItemStartPointer,
        ) -> Result<Self, String> {
            Ok(Self {
                line_number: value.line_number?,
                offset: value.offset?,
                reference: value.reference?,
            })
        }
    }
    impl From<super::Spdx23SnippetsItemRangesItemStartPointer>
    for Spdx23SnippetsItemRangesItemStartPointer {
        fn from(value: super::Spdx23SnippetsItemRangesItemStartPointer) -> Self {
            Self {
                line_number: Ok(value.line_number),
                offset: Ok(value.offset),
                reference: Ok(value.reference),
            }
        }
    }
}

