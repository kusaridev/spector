//! This file is generated by typify through Spector. Do not edit it directly.
//! Exceptions to this rule are for cases where typify doesn't genrate the correct code.
#![allow(clippy::all)]
#![allow(warnings)]
use serde::{Deserialize, Serialize};
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct Spdx22 {
    #[serde(rename = "Document", default, skip_serializing_if = "Option::is_none")]
    pub document: Option<Spdx22Document>,
}
impl From<&Spdx22> for Spdx22 {
    fn from(value: &Spdx22) -> Self {
        value.clone()
    }
}
impl Spdx22 {
    pub fn builder() -> builder::Spdx22 {
        builder::Spdx22::default()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct Spdx22Document {
    ///Provide additional information about an SpdxElement.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub annotations: Vec<Spdx22DocumentAnnotationsItem>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    #[serde(rename = "creationInfo", default, skip_serializing_if = "Option::is_none")]
    pub creation_info: Option<Spdx22DocumentCreationInfo>,
    ///License expression for dataLicense.  Compliance with the SPDX specification includes populating the SPDX fields therein with data related to such fields ("SPDX-Metadata"). The SPDX specification contains numerous fields where an SPDX document creator may provide relevant explanatory text in SPDX-Metadata. Without opining on the lawfulness of "database rights" (in jurisdictions where applicable), such explanatory text is copyrightable subject matter in most Berne Convention countries. By using the SPDX specification, or any portion hereof, you hereby agree that any copyright rights (as determined by your jurisdiction) in any SPDX-Metadata, including without limitation explanatory text, shall be subject to the terms of the Creative Commons CC0 1.0 Universal license. For SPDX-Metadata not containing any copyright rights, you hereby agree and acknowledge that the SPDX-Metadata is provided to you "as-is" and without any representations or warranties of any kind concerning the SPDX-Metadata, express, implied, statutory or otherwise, including without limitation warranties of title, merchantability, fitness for a particular purpose, non-infringement, or the absence of latent or other defects, accuracy, or the presence or absence of errors, whether or not discoverable, all to the greatest extent permissible under applicable law.
    #[serde(rename = "dataLicense", default, skip_serializing_if = "Option::is_none")]
    pub data_license: Option<String>,
    ///The describesPackage property relates an SpdxDocument to the package which it describes.
    #[serde(
        rename = "describesPackages",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub describes_packages: Vec<String>,
    ///Identify any external SPDX documents referenced within this SPDX document.
    #[serde(
        rename = "externalDocumentRefs",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub external_document_refs: Vec<Spdx22DocumentExternalDocumentRefsItem>,
    ///Files referenced in the SPDX document
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub files: Vec<Spdx22DocumentFilesItem>,
    ///Indicates that a particular ExtractedLicensingInfo was defined in the subject SpdxDocument.
    #[serde(
        rename = "hasExtractedLicensingInfos",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub has_extracted_licensing_infos: Vec<Spdx22DocumentHasExtractedLicensingInfosItem>,
    ///Identify name of this SpdxElement.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    ///Packages referenced in the SPDX document
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub packages: Vec<Spdx22DocumentPackagesItem>,
    ///Relationships referenced in the SPDX document
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub relationships: Vec<Spdx22DocumentRelationshipsItem>,
    ///Reviewed
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub revieweds: Vec<Spdx22DocumentReviewedsItem>,
    ///Snippets referenced in the SPDX document
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub snippets: Vec<Spdx22DocumentSnippetsItem>,
    ///Provide a reference number that can be used to understand how to parse and interpret the rest of the file. It will enable both future changes to the specification and to support backward compatibility. The version number consists of a major and minor version indicator. The major field will be incremented when incompatible changes between versions are made (one or more sections are created, modified or deleted). The minor field will be incremented when backwards compatible changes are made.
    #[serde(rename = "spdxVersion", default, skip_serializing_if = "Option::is_none")]
    pub spdx_version: Option<String>,
}
impl From<&Spdx22Document> for Spdx22Document {
    fn from(value: &Spdx22Document) -> Self {
        value.clone()
    }
}
impl Spdx22Document {
    pub fn builder() -> builder::Spdx22Document {
        builder::Spdx22Document::default()
    }
}
///An Annotation is a comment on an SpdxItem by an agent.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct Spdx22DocumentAnnotationsItem {
    ///Identify when the comment was made. This is to be specified according to the combined date and time in the UTC format, as specified in the ISO 8601 standard.
    #[serde(rename = "annotationDate", default, skip_serializing_if = "Option::is_none")]
    pub annotation_date: Option<String>,
    ///Type of the annotation.
    #[serde(rename = "annotationType", default, skip_serializing_if = "Option::is_none")]
    pub annotation_type: Option<Spdx22DocumentAnnotationsItemAnnotationType>,
    ///This field identifies the person, organization or tool that has commented on a file, package, or the entire document.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotator: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
}
impl From<&Spdx22DocumentAnnotationsItem> for Spdx22DocumentAnnotationsItem {
    fn from(value: &Spdx22DocumentAnnotationsItem) -> Self {
        value.clone()
    }
}
impl Spdx22DocumentAnnotationsItem {
    pub fn builder() -> builder::Spdx22DocumentAnnotationsItem {
        builder::Spdx22DocumentAnnotationsItem::default()
    }
}
///Type of the annotation.
#[derive(
    Clone,
    Copy,
    Debug,
    Deserialize,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
    Serialize,
    schemars::JsonSchema
)]
pub enum Spdx22DocumentAnnotationsItemAnnotationType {
    #[serde(rename = "OTHER")]
    Other,
    #[serde(rename = "REVIEW")]
    Review,
}
impl From<&Spdx22DocumentAnnotationsItemAnnotationType>
for Spdx22DocumentAnnotationsItemAnnotationType {
    fn from(value: &Spdx22DocumentAnnotationsItemAnnotationType) -> Self {
        value.clone()
    }
}
impl ToString for Spdx22DocumentAnnotationsItemAnnotationType {
    fn to_string(&self) -> String {
        match *self {
            Self::Other => "OTHER".to_string(),
            Self::Review => "REVIEW".to_string(),
        }
    }
}
impl std::str::FromStr for Spdx22DocumentAnnotationsItemAnnotationType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "OTHER" => Ok(Self::Other),
            "REVIEW" => Ok(Self::Review),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for Spdx22DocumentAnnotationsItemAnnotationType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for Spdx22DocumentAnnotationsItemAnnotationType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for Spdx22DocumentAnnotationsItemAnnotationType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
///One instance is required for each SPDX file produced. It provides the necessary information for forward and backward compatibility for processing tools.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct Spdx22DocumentCreationInfo {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    ///Identify when the SPDX file was originally created. The date is to be specified according to combined date and time in UTC format as specified in ISO 8601 standard. This field is distinct from the fields in section 8, which involves the addition of information during a subsequent review.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created: Option<String>,
    ///Identify who (or what, in the case of a tool) created the SPDX file. If the SPDX file was created by an individual, indicate the person's name. If the SPDX file was created on behalf of a company or organization, indicate the entity name. If the SPDX file was created using a software tool, indicate the name and version for that tool. If multiple participants or tools were involved, use multiple instances of this field. Person name or organization name may be designated as “anonymous” if appropriate.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub creators: Vec<String>,
    ///An optional field for creators of the SPDX file to provide the version of the SPDX License List used when the SPDX file was created.
    #[serde(
        rename = "licenseListVersion",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub license_list_version: Option<String>,
}
impl From<&Spdx22DocumentCreationInfo> for Spdx22DocumentCreationInfo {
    fn from(value: &Spdx22DocumentCreationInfo) -> Self {
        value.clone()
    }
}
impl Spdx22DocumentCreationInfo {
    pub fn builder() -> builder::Spdx22DocumentCreationInfo {
        builder::Spdx22DocumentCreationInfo::default()
    }
}
///Information about an external SPDX document reference including the checksum. This allows for verification of the external references.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct Spdx22DocumentExternalDocumentRefsItem {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub checksum: Option<Spdx22DocumentExternalDocumentRefsItemChecksum>,
    ///externalDocumentId is a string containing letters, numbers, ., - and/or + which uniquely identifies an external document within this document.
    #[serde(
        rename = "externalDocumentId",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub external_document_id: Option<String>,
    ///SPDX ID for SpdxDocument.  A propoerty containing an SPDX document.
    #[serde(rename = "spdxDocument", default, skip_serializing_if = "Option::is_none")]
    pub spdx_document: Option<String>,
}
impl From<&Spdx22DocumentExternalDocumentRefsItem>
for Spdx22DocumentExternalDocumentRefsItem {
    fn from(value: &Spdx22DocumentExternalDocumentRefsItem) -> Self {
        value.clone()
    }
}
impl Spdx22DocumentExternalDocumentRefsItem {
    pub fn builder() -> builder::Spdx22DocumentExternalDocumentRefsItem {
        builder::Spdx22DocumentExternalDocumentRefsItem::default()
    }
}
///A Checksum is value that allows the contents of a file to be authenticated. Even small changes to the content of the file will change its checksum. This class allows the results of a variety of checksum and cryptographic message digest algorithms to be represented.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct Spdx22DocumentExternalDocumentRefsItemChecksum {
    ///Identifies the algorithm used to produce the subject Checksum. Currently, SHA-1 is the only supported algorithm. It is anticipated that other algorithms will be supported at a later time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub algorithm: Option<Spdx22DocumentExternalDocumentRefsItemChecksumAlgorithm>,
    ///The checksumValue property provides a lower case hexidecimal encoded digest value produced using a specific algorithm.
    #[serde(rename = "checksumValue", default, skip_serializing_if = "Option::is_none")]
    pub checksum_value: Option<String>,
}
impl From<&Spdx22DocumentExternalDocumentRefsItemChecksum>
for Spdx22DocumentExternalDocumentRefsItemChecksum {
    fn from(value: &Spdx22DocumentExternalDocumentRefsItemChecksum) -> Self {
        value.clone()
    }
}
impl Spdx22DocumentExternalDocumentRefsItemChecksum {
    pub fn builder() -> builder::Spdx22DocumentExternalDocumentRefsItemChecksum {
        builder::Spdx22DocumentExternalDocumentRefsItemChecksum::default()
    }
}
///Identifies the algorithm used to produce the subject Checksum. Currently, SHA-1 is the only supported algorithm. It is anticipated that other algorithms will be supported at a later time.
#[derive(
    Clone,
    Copy,
    Debug,
    Deserialize,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
    Serialize,
    schemars::JsonSchema
)]
pub enum Spdx22DocumentExternalDocumentRefsItemChecksumAlgorithm {
    #[serde(rename = "SHA256")]
    Sha256,
    #[serde(rename = "SHA1")]
    Sha1,
    #[serde(rename = "SHA384")]
    Sha384,
    #[serde(rename = "MD2")]
    Md2,
    #[serde(rename = "MD4")]
    Md4,
    #[serde(rename = "SHA512")]
    Sha512,
    #[serde(rename = "MD6")]
    Md6,
    #[serde(rename = "MD5")]
    Md5,
    #[serde(rename = "SHA224")]
    Sha224,
}
impl From<&Spdx22DocumentExternalDocumentRefsItemChecksumAlgorithm>
for Spdx22DocumentExternalDocumentRefsItemChecksumAlgorithm {
    fn from(value: &Spdx22DocumentExternalDocumentRefsItemChecksumAlgorithm) -> Self {
        value.clone()
    }
}
impl ToString for Spdx22DocumentExternalDocumentRefsItemChecksumAlgorithm {
    fn to_string(&self) -> String {
        match *self {
            Self::Sha256 => "SHA256".to_string(),
            Self::Sha1 => "SHA1".to_string(),
            Self::Sha384 => "SHA384".to_string(),
            Self::Md2 => "MD2".to_string(),
            Self::Md4 => "MD4".to_string(),
            Self::Sha512 => "SHA512".to_string(),
            Self::Md6 => "MD6".to_string(),
            Self::Md5 => "MD5".to_string(),
            Self::Sha224 => "SHA224".to_string(),
        }
    }
}
impl std::str::FromStr for Spdx22DocumentExternalDocumentRefsItemChecksumAlgorithm {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "SHA256" => Ok(Self::Sha256),
            "SHA1" => Ok(Self::Sha1),
            "SHA384" => Ok(Self::Sha384),
            "MD2" => Ok(Self::Md2),
            "MD4" => Ok(Self::Md4),
            "SHA512" => Ok(Self::Sha512),
            "MD6" => Ok(Self::Md6),
            "MD5" => Ok(Self::Md5),
            "SHA224" => Ok(Self::Sha224),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
for Spdx22DocumentExternalDocumentRefsItemChecksumAlgorithm {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
for Spdx22DocumentExternalDocumentRefsItemChecksumAlgorithm {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
for Spdx22DocumentExternalDocumentRefsItemChecksumAlgorithm {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct Spdx22DocumentFilesItem {
    ///Provide additional information about an SpdxElement.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub annotations: Vec<Spdx22DocumentFilesItemAnnotationsItem>,
    ///Indicates the project in which the SpdxElement originated. Tools must preserve doap:homepage and doap:name properties and the URI (if one is known) of doap:Project resources that are values of this property. All other properties of doap:Projects are not directly supported by SPDX and may be dropped when translating to or from some SPDX formats.
    #[serde(rename = "artifactOfs", default, skip_serializing_if = "Vec::is_empty")]
    pub artifact_ofs: Vec<std::collections::HashMap<String, serde_json::Value>>,
    ///This field provides a place for the SPDX data creator to record acknowledgements that may be required to be communicated in some contexts. This is not meant to include theactual complete license text (see licenseConculded and licenseDeclared), and may or may not include copyright notices (see also copyrightText). The SPDX data creator may use this field to record other acknowledgements, such as particular clauses from license texts, which may be necessary or desirable to reproduce.
    #[serde(rename = "attributionTexts", default, skip_serializing_if = "Vec::is_empty")]
    pub attribution_texts: Vec<String>,
    ///The checksum property provides a mechanism that can be used to verify that the contents of a File or Package have not changed.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub checksums: Vec<Spdx22DocumentFilesItemChecksumsItem>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    ///The text of copyright declarations recited in the Package or File.
    #[serde(rename = "copyrightText", default, skip_serializing_if = "Option::is_none")]
    pub copyright_text: Option<String>,
    ///This field provides a place for the SPDX file creator to record file contributors. Contributors could include names of copyright holders and/or authors who may not be copyright holders yet contributed to the file content.
    #[serde(rename = "fileContributors", default, skip_serializing_if = "Vec::is_empty")]
    pub file_contributors: Vec<String>,
    #[serde(rename = "fileDependencies", default, skip_serializing_if = "Vec::is_empty")]
    pub file_dependencies: Vec<String>,
    ///The name of the file relative to the root of the package.
    #[serde(rename = "fileName", default, skip_serializing_if = "Option::is_none")]
    pub file_name: Option<String>,
    ///The type of the file.
    #[serde(rename = "fileTypes", default, skip_serializing_if = "Vec::is_empty")]
    pub file_types: Vec<Spdx22DocumentFilesItemFileTypesItem>,
    ///The licenseComments property allows the preparer of the SPDX document to describe why the licensing in spdx:licenseConcluded was chosen.
    #[serde(
        rename = "licenseComments",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub license_comments: Option<String>,
    ///The licensing information that was discovered directly within the package. There will be an instance of this property for each distinct value of alllicenseInfoInFile properties of all files contained in the package.
    #[serde(
        rename = "licenseInfoFromFiles",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub license_info_from_files: Vec<String>,
    ///Licensing information that was discovered directly in the subject file. This is also considered a declared license for the file.
    #[serde(
        rename = "licenseInfoInFiles",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub license_info_in_files: Vec<String>,
    ///Identify name of this SpdxElement.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    ///This field provides a place for the SPDX file creator to record potential legal notices found in the file. This may or may not include copyright statements.
    #[serde(rename = "noticeText", default, skip_serializing_if = "Option::is_none")]
    pub notice_text: Option<String>,
}
impl From<&Spdx22DocumentFilesItem> for Spdx22DocumentFilesItem {
    fn from(value: &Spdx22DocumentFilesItem) -> Self {
        value.clone()
    }
}
impl Spdx22DocumentFilesItem {
    pub fn builder() -> builder::Spdx22DocumentFilesItem {
        builder::Spdx22DocumentFilesItem::default()
    }
}
///An Annotation is a comment on an SpdxItem by an agent.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct Spdx22DocumentFilesItemAnnotationsItem {
    ///Identify when the comment was made. This is to be specified according to the combined date and time in the UTC format, as specified in the ISO 8601 standard.
    #[serde(rename = "annotationDate", default, skip_serializing_if = "Option::is_none")]
    pub annotation_date: Option<String>,
    ///Type of the annotation.
    #[serde(rename = "annotationType", default, skip_serializing_if = "Option::is_none")]
    pub annotation_type: Option<Spdx22DocumentFilesItemAnnotationsItemAnnotationType>,
    ///This field identifies the person, organization or tool that has commented on a file, package, or the entire document.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotator: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
}
impl From<&Spdx22DocumentFilesItemAnnotationsItem>
for Spdx22DocumentFilesItemAnnotationsItem {
    fn from(value: &Spdx22DocumentFilesItemAnnotationsItem) -> Self {
        value.clone()
    }
}
impl Spdx22DocumentFilesItemAnnotationsItem {
    pub fn builder() -> builder::Spdx22DocumentFilesItemAnnotationsItem {
        builder::Spdx22DocumentFilesItemAnnotationsItem::default()
    }
}
///Type of the annotation.
#[derive(
    Clone,
    Copy,
    Debug,
    Deserialize,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
    Serialize,
    schemars::JsonSchema
)]
pub enum Spdx22DocumentFilesItemAnnotationsItemAnnotationType {
    #[serde(rename = "OTHER")]
    Other,
    #[serde(rename = "REVIEW")]
    Review,
}
impl From<&Spdx22DocumentFilesItemAnnotationsItemAnnotationType>
for Spdx22DocumentFilesItemAnnotationsItemAnnotationType {
    fn from(value: &Spdx22DocumentFilesItemAnnotationsItemAnnotationType) -> Self {
        value.clone()
    }
}
impl ToString for Spdx22DocumentFilesItemAnnotationsItemAnnotationType {
    fn to_string(&self) -> String {
        match *self {
            Self::Other => "OTHER".to_string(),
            Self::Review => "REVIEW".to_string(),
        }
    }
}
impl std::str::FromStr for Spdx22DocumentFilesItemAnnotationsItemAnnotationType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "OTHER" => Ok(Self::Other),
            "REVIEW" => Ok(Self::Review),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
for Spdx22DocumentFilesItemAnnotationsItemAnnotationType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
for Spdx22DocumentFilesItemAnnotationsItemAnnotationType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
for Spdx22DocumentFilesItemAnnotationsItemAnnotationType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
///A Checksum is value that allows the contents of a file to be authenticated. Even small changes to the content of the file will change its checksum. This class allows the results of a variety of checksum and cryptographic message digest algorithms to be represented.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct Spdx22DocumentFilesItemChecksumsItem {
    ///Identifies the algorithm used to produce the subject Checksum. Currently, SHA-1 is the only supported algorithm. It is anticipated that other algorithms will be supported at a later time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub algorithm: Option<Spdx22DocumentFilesItemChecksumsItemAlgorithm>,
    ///The checksumValue property provides a lower case hexidecimal encoded digest value produced using a specific algorithm.
    #[serde(rename = "checksumValue", default, skip_serializing_if = "Option::is_none")]
    pub checksum_value: Option<String>,
}
impl From<&Spdx22DocumentFilesItemChecksumsItem>
for Spdx22DocumentFilesItemChecksumsItem {
    fn from(value: &Spdx22DocumentFilesItemChecksumsItem) -> Self {
        value.clone()
    }
}
impl Spdx22DocumentFilesItemChecksumsItem {
    pub fn builder() -> builder::Spdx22DocumentFilesItemChecksumsItem {
        builder::Spdx22DocumentFilesItemChecksumsItem::default()
    }
}
///Identifies the algorithm used to produce the subject Checksum. Currently, SHA-1 is the only supported algorithm. It is anticipated that other algorithms will be supported at a later time.
#[derive(
    Clone,
    Copy,
    Debug,
    Deserialize,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
    Serialize,
    schemars::JsonSchema
)]
pub enum Spdx22DocumentFilesItemChecksumsItemAlgorithm {
    #[serde(rename = "SHA256")]
    Sha256,
    #[serde(rename = "SHA1")]
    Sha1,
    #[serde(rename = "SHA384")]
    Sha384,
    #[serde(rename = "MD2")]
    Md2,
    #[serde(rename = "MD4")]
    Md4,
    #[serde(rename = "SHA512")]
    Sha512,
    #[serde(rename = "MD6")]
    Md6,
    #[serde(rename = "MD5")]
    Md5,
    #[serde(rename = "SHA224")]
    Sha224,
}
impl From<&Spdx22DocumentFilesItemChecksumsItemAlgorithm>
for Spdx22DocumentFilesItemChecksumsItemAlgorithm {
    fn from(value: &Spdx22DocumentFilesItemChecksumsItemAlgorithm) -> Self {
        value.clone()
    }
}
impl ToString for Spdx22DocumentFilesItemChecksumsItemAlgorithm {
    fn to_string(&self) -> String {
        match *self {
            Self::Sha256 => "SHA256".to_string(),
            Self::Sha1 => "SHA1".to_string(),
            Self::Sha384 => "SHA384".to_string(),
            Self::Md2 => "MD2".to_string(),
            Self::Md4 => "MD4".to_string(),
            Self::Sha512 => "SHA512".to_string(),
            Self::Md6 => "MD6".to_string(),
            Self::Md5 => "MD5".to_string(),
            Self::Sha224 => "SHA224".to_string(),
        }
    }
}
impl std::str::FromStr for Spdx22DocumentFilesItemChecksumsItemAlgorithm {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "SHA256" => Ok(Self::Sha256),
            "SHA1" => Ok(Self::Sha1),
            "SHA384" => Ok(Self::Sha384),
            "MD2" => Ok(Self::Md2),
            "MD4" => Ok(Self::Md4),
            "SHA512" => Ok(Self::Sha512),
            "MD6" => Ok(Self::Md6),
            "MD5" => Ok(Self::Md5),
            "SHA224" => Ok(Self::Sha224),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for Spdx22DocumentFilesItemChecksumsItemAlgorithm {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for Spdx22DocumentFilesItemChecksumsItemAlgorithm {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for Spdx22DocumentFilesItemChecksumsItemAlgorithm {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
///The type of the file.
#[derive(
    Clone,
    Copy,
    Debug,
    Deserialize,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
    Serialize,
    schemars::JsonSchema
)]
pub enum Spdx22DocumentFilesItemFileTypesItem {
    #[serde(rename = "OTHER")]
    Other,
    #[serde(rename = "DOCUMENTATION")]
    Documentation,
    #[serde(rename = "IMAGE")]
    Image,
    #[serde(rename = "VIDEO")]
    Video,
    #[serde(rename = "ARCHIVE")]
    Archive,
    #[serde(rename = "SPDX")]
    Spdx,
    #[serde(rename = "APPLICATION")]
    Application,
    #[serde(rename = "SOURCE")]
    Source,
    #[serde(rename = "BINARY")]
    Binary,
    #[serde(rename = "TEXT")]
    Text,
    #[serde(rename = "AUDIO")]
    Audio,
}
impl From<&Spdx22DocumentFilesItemFileTypesItem>
for Spdx22DocumentFilesItemFileTypesItem {
    fn from(value: &Spdx22DocumentFilesItemFileTypesItem) -> Self {
        value.clone()
    }
}
impl ToString for Spdx22DocumentFilesItemFileTypesItem {
    fn to_string(&self) -> String {
        match *self {
            Self::Other => "OTHER".to_string(),
            Self::Documentation => "DOCUMENTATION".to_string(),
            Self::Image => "IMAGE".to_string(),
            Self::Video => "VIDEO".to_string(),
            Self::Archive => "ARCHIVE".to_string(),
            Self::Spdx => "SPDX".to_string(),
            Self::Application => "APPLICATION".to_string(),
            Self::Source => "SOURCE".to_string(),
            Self::Binary => "BINARY".to_string(),
            Self::Text => "TEXT".to_string(),
            Self::Audio => "AUDIO".to_string(),
        }
    }
}
impl std::str::FromStr for Spdx22DocumentFilesItemFileTypesItem {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "OTHER" => Ok(Self::Other),
            "DOCUMENTATION" => Ok(Self::Documentation),
            "IMAGE" => Ok(Self::Image),
            "VIDEO" => Ok(Self::Video),
            "ARCHIVE" => Ok(Self::Archive),
            "SPDX" => Ok(Self::Spdx),
            "APPLICATION" => Ok(Self::Application),
            "SOURCE" => Ok(Self::Source),
            "BINARY" => Ok(Self::Binary),
            "TEXT" => Ok(Self::Text),
            "AUDIO" => Ok(Self::Audio),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for Spdx22DocumentFilesItemFileTypesItem {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for Spdx22DocumentFilesItemFileTypesItem {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for Spdx22DocumentFilesItemFileTypesItem {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
///An ExtractedLicensingInfo represents a license or licensing notice that was found in the package. Any license text that is recognized as a license may be represented as a License rather than an ExtractedLicensingInfo.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct Spdx22DocumentHasExtractedLicensingInfosItem {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    ///Verbatim license or licensing notice text that was discovered.
    #[serde(rename = "extractedText", default, skip_serializing_if = "Option::is_none")]
    pub extracted_text: Option<String>,
    ///A human readable short form license identifier for a license. The license ID is iether on the standard license oist or the form "LicenseRef-"[idString] where [idString] is a unique string containing letters, numbers, ".", "-" or "+".
    #[serde(rename = "licenseId", default, skip_serializing_if = "Option::is_none")]
    pub license_id: Option<String>,
    ///Identify name of this SpdxElement.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "seeAlsos", default, skip_serializing_if = "Vec::is_empty")]
    pub see_alsos: Vec<String>,
}
impl From<&Spdx22DocumentHasExtractedLicensingInfosItem>
for Spdx22DocumentHasExtractedLicensingInfosItem {
    fn from(value: &Spdx22DocumentHasExtractedLicensingInfosItem) -> Self {
        value.clone()
    }
}
impl Spdx22DocumentHasExtractedLicensingInfosItem {
    pub fn builder() -> builder::Spdx22DocumentHasExtractedLicensingInfosItem {
        builder::Spdx22DocumentHasExtractedLicensingInfosItem::default()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct Spdx22DocumentPackagesItem {
    ///Provide additional information about an SpdxElement.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub annotations: Vec<Spdx22DocumentPackagesItemAnnotationsItem>,
    ///This field provides a place for the SPDX data creator to record acknowledgements that may be required to be communicated in some contexts. This is not meant to include theactual complete license text (see licenseConculded and licenseDeclared), and may or may not include copyright notices (see also copyrightText). The SPDX data creator may use this field to record other acknowledgements, such as particular clauses from license texts, which may be necessary or desirable to reproduce.
    #[serde(rename = "attributionTexts", default, skip_serializing_if = "Vec::is_empty")]
    pub attribution_texts: Vec<String>,
    ///The checksum property provides a mechanism that can be used to verify that the contents of a File or Package have not changed.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub checksums: Vec<Spdx22DocumentPackagesItemChecksumsItem>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    ///The text of copyright declarations recited in the Package or File.
    #[serde(rename = "copyrightText", default, skip_serializing_if = "Option::is_none")]
    pub copyright_text: Option<String>,
    ///Provides a detailed description of the package.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    ///The URI at which this package is available for download. Private (i.e., not publicly reachable) URIs are acceptable as values of this property. The values http://spdx.org/rdf/terms#none and http://spdx.org/rdf/terms#noassertion may be used to specify that the package is not downloadable or that no attempt was made to determine its download location, respectively.
    #[serde(
        rename = "downloadLocation",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub download_location: Option<String>,
    ///An External Reference allows a Package to reference an external source of additional information, metadata, enumerations, asset identifiers, or downloadable content believed to be relevant to the Package.
    #[serde(rename = "externalRefs", default, skip_serializing_if = "Vec::is_empty")]
    pub external_refs: Vec<Spdx22DocumentPackagesItemExternalRefsItem>,
    ///Indicates whether the file content of this package has been available for or subjected to analysis when creating the SPDX document. If false indicates packages that represent metadata or URI references to a project, product, artifact, distribution or a component. If set to false, the package must not contain any files.
    #[serde(rename = "filesAnalyzed", default, skip_serializing_if = "Option::is_none")]
    pub files_analyzed: Option<bool>,
    ///Indicates that a particular file belongs to a package.
    #[serde(rename = "hasFiles", default, skip_serializing_if = "Vec::is_empty")]
    pub has_files: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub homepage: Option<String>,
    ///The licenseComments property allows the preparer of the SPDX document to describe why the licensing in spdx:licenseConcluded was chosen.
    #[serde(
        rename = "licenseComments",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub license_comments: Option<String>,
    ///The licensing information that was discovered directly within the package. There will be an instance of this property for each distinct value of alllicenseInfoInFile properties of all files contained in the package.
    #[serde(
        rename = "licenseInfoFromFiles",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub license_info_from_files: Vec<String>,
    ///Identify name of this SpdxElement.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    ///The name and, optionally, contact information of the person or organization that originally created the package. Values of this property must conform to the agent and tool syntax.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub originator: Option<String>,
    ///The base name of the package file name. For example, zlib-1.2.5.tar.gz.
    #[serde(
        rename = "packageFileName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub package_file_name: Option<String>,
    #[serde(
        rename = "packageVerificationCode",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub package_verification_code: Option<
        Spdx22DocumentPackagesItemPackageVerificationCode,
    >,
    ///Allows the producer(s) of the SPDX document to describe how the package was acquired and/or changed from the original source.
    #[serde(rename = "sourceInfo", default, skip_serializing_if = "Option::is_none")]
    pub source_info: Option<String>,
    ///Provides a short description of the package.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    ///The name and, optionally, contact information of the person or organization who was the immediate supplier of this package to the recipient. The supplier may be different than originator when the software has been repackaged. Values of this property must conform to the agent and tool syntax.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub supplier: Option<String>,
    ///Provides an indication of the version of the package that is described by this SpdxDocument.
    #[serde(rename = "versionInfo", default, skip_serializing_if = "Option::is_none")]
    pub version_info: Option<String>,
}
impl From<&Spdx22DocumentPackagesItem> for Spdx22DocumentPackagesItem {
    fn from(value: &Spdx22DocumentPackagesItem) -> Self {
        value.clone()
    }
}
impl Spdx22DocumentPackagesItem {
    pub fn builder() -> builder::Spdx22DocumentPackagesItem {
        builder::Spdx22DocumentPackagesItem::default()
    }
}
///An Annotation is a comment on an SpdxItem by an agent.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct Spdx22DocumentPackagesItemAnnotationsItem {
    ///Identify when the comment was made. This is to be specified according to the combined date and time in the UTC format, as specified in the ISO 8601 standard.
    #[serde(rename = "annotationDate", default, skip_serializing_if = "Option::is_none")]
    pub annotation_date: Option<String>,
    ///Type of the annotation.
    #[serde(rename = "annotationType", default, skip_serializing_if = "Option::is_none")]
    pub annotation_type: Option<Spdx22DocumentPackagesItemAnnotationsItemAnnotationType>,
    ///This field identifies the person, organization or tool that has commented on a file, package, or the entire document.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotator: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
}
impl From<&Spdx22DocumentPackagesItemAnnotationsItem>
for Spdx22DocumentPackagesItemAnnotationsItem {
    fn from(value: &Spdx22DocumentPackagesItemAnnotationsItem) -> Self {
        value.clone()
    }
}
impl Spdx22DocumentPackagesItemAnnotationsItem {
    pub fn builder() -> builder::Spdx22DocumentPackagesItemAnnotationsItem {
        builder::Spdx22DocumentPackagesItemAnnotationsItem::default()
    }
}
///Type of the annotation.
#[derive(
    Clone,
    Copy,
    Debug,
    Deserialize,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
    Serialize,
    schemars::JsonSchema
)]
pub enum Spdx22DocumentPackagesItemAnnotationsItemAnnotationType {
    #[serde(rename = "OTHER")]
    Other,
    #[serde(rename = "REVIEW")]
    Review,
}
impl From<&Spdx22DocumentPackagesItemAnnotationsItemAnnotationType>
for Spdx22DocumentPackagesItemAnnotationsItemAnnotationType {
    fn from(value: &Spdx22DocumentPackagesItemAnnotationsItemAnnotationType) -> Self {
        value.clone()
    }
}
impl ToString for Spdx22DocumentPackagesItemAnnotationsItemAnnotationType {
    fn to_string(&self) -> String {
        match *self {
            Self::Other => "OTHER".to_string(),
            Self::Review => "REVIEW".to_string(),
        }
    }
}
impl std::str::FromStr for Spdx22DocumentPackagesItemAnnotationsItemAnnotationType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "OTHER" => Ok(Self::Other),
            "REVIEW" => Ok(Self::Review),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
for Spdx22DocumentPackagesItemAnnotationsItemAnnotationType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
for Spdx22DocumentPackagesItemAnnotationsItemAnnotationType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
for Spdx22DocumentPackagesItemAnnotationsItemAnnotationType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
///A Checksum is value that allows the contents of a file to be authenticated. Even small changes to the content of the file will change its checksum. This class allows the results of a variety of checksum and cryptographic message digest algorithms to be represented.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct Spdx22DocumentPackagesItemChecksumsItem {
    ///Identifies the algorithm used to produce the subject Checksum. Currently, SHA-1 is the only supported algorithm. It is anticipated that other algorithms will be supported at a later time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub algorithm: Option<Spdx22DocumentPackagesItemChecksumsItemAlgorithm>,
    ///The checksumValue property provides a lower case hexidecimal encoded digest value produced using a specific algorithm.
    #[serde(rename = "checksumValue", default, skip_serializing_if = "Option::is_none")]
    pub checksum_value: Option<String>,
}
impl From<&Spdx22DocumentPackagesItemChecksumsItem>
for Spdx22DocumentPackagesItemChecksumsItem {
    fn from(value: &Spdx22DocumentPackagesItemChecksumsItem) -> Self {
        value.clone()
    }
}
impl Spdx22DocumentPackagesItemChecksumsItem {
    pub fn builder() -> builder::Spdx22DocumentPackagesItemChecksumsItem {
        builder::Spdx22DocumentPackagesItemChecksumsItem::default()
    }
}
///Identifies the algorithm used to produce the subject Checksum. Currently, SHA-1 is the only supported algorithm. It is anticipated that other algorithms will be supported at a later time.
#[derive(
    Clone,
    Copy,
    Debug,
    Deserialize,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
    Serialize,
    schemars::JsonSchema
)]
pub enum Spdx22DocumentPackagesItemChecksumsItemAlgorithm {
    #[serde(rename = "SHA256")]
    Sha256,
    #[serde(rename = "SHA1")]
    Sha1,
    #[serde(rename = "SHA384")]
    Sha384,
    #[serde(rename = "MD2")]
    Md2,
    #[serde(rename = "MD4")]
    Md4,
    #[serde(rename = "SHA512")]
    Sha512,
    #[serde(rename = "MD6")]
    Md6,
    #[serde(rename = "MD5")]
    Md5,
    #[serde(rename = "SHA224")]
    Sha224,
}
impl From<&Spdx22DocumentPackagesItemChecksumsItemAlgorithm>
for Spdx22DocumentPackagesItemChecksumsItemAlgorithm {
    fn from(value: &Spdx22DocumentPackagesItemChecksumsItemAlgorithm) -> Self {
        value.clone()
    }
}
impl ToString for Spdx22DocumentPackagesItemChecksumsItemAlgorithm {
    fn to_string(&self) -> String {
        match *self {
            Self::Sha256 => "SHA256".to_string(),
            Self::Sha1 => "SHA1".to_string(),
            Self::Sha384 => "SHA384".to_string(),
            Self::Md2 => "MD2".to_string(),
            Self::Md4 => "MD4".to_string(),
            Self::Sha512 => "SHA512".to_string(),
            Self::Md6 => "MD6".to_string(),
            Self::Md5 => "MD5".to_string(),
            Self::Sha224 => "SHA224".to_string(),
        }
    }
}
impl std::str::FromStr for Spdx22DocumentPackagesItemChecksumsItemAlgorithm {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "SHA256" => Ok(Self::Sha256),
            "SHA1" => Ok(Self::Sha1),
            "SHA384" => Ok(Self::Sha384),
            "MD2" => Ok(Self::Md2),
            "MD4" => Ok(Self::Md4),
            "SHA512" => Ok(Self::Sha512),
            "MD6" => Ok(Self::Md6),
            "MD5" => Ok(Self::Md5),
            "SHA224" => Ok(Self::Sha224),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for Spdx22DocumentPackagesItemChecksumsItemAlgorithm {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
for Spdx22DocumentPackagesItemChecksumsItemAlgorithm {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for Spdx22DocumentPackagesItemChecksumsItemAlgorithm {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
///An External Reference allows a Package to reference an external source of additional information, metadata, enumerations, asset identifiers, or downloadable content believed to be relevant to the Package.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct Spdx22DocumentPackagesItemExternalRefsItem {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    ///Category for the external reference
    #[serde(
        rename = "referenceCategory",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub reference_category: Option<
        Spdx22DocumentPackagesItemExternalRefsItemReferenceCategory,
    >,
    ///The unique string with no spaces necessary to access the package-specific information, metadata, or content within the target location. The format of the locator is subject to constraints defined by the <type>.
    #[serde(
        rename = "referenceLocator",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub reference_locator: Option<String>,
    ///Type of the external reference. These are definined in an appendix in the SPDX specification.
    #[serde(rename = "referenceType", default, skip_serializing_if = "Option::is_none")]
    pub reference_type: Option<String>,
}
impl From<&Spdx22DocumentPackagesItemExternalRefsItem>
for Spdx22DocumentPackagesItemExternalRefsItem {
    fn from(value: &Spdx22DocumentPackagesItemExternalRefsItem) -> Self {
        value.clone()
    }
}
impl Spdx22DocumentPackagesItemExternalRefsItem {
    pub fn builder() -> builder::Spdx22DocumentPackagesItemExternalRefsItem {
        builder::Spdx22DocumentPackagesItemExternalRefsItem::default()
    }
}
///Category for the external reference
#[derive(
    Clone,
    Copy,
    Debug,
    Deserialize,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
    Serialize,
    schemars::JsonSchema
)]
pub enum Spdx22DocumentPackagesItemExternalRefsItemReferenceCategory {
    #[serde(rename = "OTHER")]
    Other,
    #[serde(rename = "SECURITY")]
    Security,
    #[serde(rename = "PACKAGE_MANAGER")]
    PackageManager,
}
impl From<&Spdx22DocumentPackagesItemExternalRefsItemReferenceCategory>
for Spdx22DocumentPackagesItemExternalRefsItemReferenceCategory {
    fn from(
        value: &Spdx22DocumentPackagesItemExternalRefsItemReferenceCategory,
    ) -> Self {
        value.clone()
    }
}
impl ToString for Spdx22DocumentPackagesItemExternalRefsItemReferenceCategory {
    fn to_string(&self) -> String {
        match *self {
            Self::Other => "OTHER".to_string(),
            Self::Security => "SECURITY".to_string(),
            Self::PackageManager => "PACKAGE_MANAGER".to_string(),
        }
    }
}
impl std::str::FromStr for Spdx22DocumentPackagesItemExternalRefsItemReferenceCategory {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "OTHER" => Ok(Self::Other),
            "SECURITY" => Ok(Self::Security),
            "PACKAGE_MANAGER" => Ok(Self::PackageManager),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
for Spdx22DocumentPackagesItemExternalRefsItemReferenceCategory {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
for Spdx22DocumentPackagesItemExternalRefsItemReferenceCategory {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
for Spdx22DocumentPackagesItemExternalRefsItemReferenceCategory {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
///A manifest based verification code (the algorithm is defined in section 4.7 of the full specification) of the SPDX Item. This allows consumers of this data and/or database to determine if an SPDX item they have in hand is identical to the SPDX item from which the data was produced. This algorithm works even if the SPDX document is included in the SPDX item.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct Spdx22DocumentPackagesItemPackageVerificationCode {
    ///A file that was excluded when calculating the package verification code. This is usually a file containing SPDX data regarding the package. If a package contains more than one SPDX file all SPDX files must be excluded from the package verification code. If this is not done it would be impossible to correctly calculate the verification codes in both files.
    #[serde(
        rename = "packageVerificationCodeExcludedFiles",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub package_verification_code_excluded_files: Vec<String>,
    ///The actual package verification code as a hex encoded value.
    #[serde(
        rename = "packageVerificationCodeValue",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub package_verification_code_value: Option<String>,
}
impl From<&Spdx22DocumentPackagesItemPackageVerificationCode>
for Spdx22DocumentPackagesItemPackageVerificationCode {
    fn from(value: &Spdx22DocumentPackagesItemPackageVerificationCode) -> Self {
        value.clone()
    }
}
impl Spdx22DocumentPackagesItemPackageVerificationCode {
    pub fn builder() -> builder::Spdx22DocumentPackagesItemPackageVerificationCode {
        builder::Spdx22DocumentPackagesItemPackageVerificationCode::default()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct Spdx22DocumentRelationshipsItem {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    ///SPDX ID for SpdxElement.  A related SpdxElement.
    #[serde(
        rename = "relatedSpdxElement",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub related_spdx_element: Option<String>,
    ///Describes the type of relationship between two SPDX elements.
    #[serde(
        rename = "relationshipType",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub relationship_type: Option<Spdx22DocumentRelationshipsItemRelationshipType>,
}
impl From<&Spdx22DocumentRelationshipsItem> for Spdx22DocumentRelationshipsItem {
    fn from(value: &Spdx22DocumentRelationshipsItem) -> Self {
        value.clone()
    }
}
impl Spdx22DocumentRelationshipsItem {
    pub fn builder() -> builder::Spdx22DocumentRelationshipsItem {
        builder::Spdx22DocumentRelationshipsItem::default()
    }
}
///Describes the type of relationship between two SPDX elements.
#[derive(
    Clone,
    Copy,
    Debug,
    Deserialize,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
    Serialize,
    schemars::JsonSchema
)]
pub enum Spdx22DocumentRelationshipsItemRelationshipType {
    #[serde(rename = "VARIANT_OF")]
    VariantOf,
    #[serde(rename = "COPY_OF")]
    CopyOf,
    #[serde(rename = "PATCH_FOR")]
    PatchFor,
    #[serde(rename = "TEST_DEPENDENCY_OF")]
    TestDependencyOf,
    #[serde(rename = "CONTAINED_BY")]
    ContainedBy,
    #[serde(rename = "DATA_FILE_OF")]
    DataFileOf,
    #[serde(rename = "OPTIONAL_COMPONENT_OF")]
    OptionalComponentOf,
    #[serde(rename = "ANCESTOR_OF")]
    AncestorOf,
    #[serde(rename = "GENERATES")]
    Generates,
    #[serde(rename = "CONTAINS")]
    Contains,
    #[serde(rename = "OPTIONAL_DEPENDENCY_OF")]
    OptionalDependencyOf,
    #[serde(rename = "FILE_ADDED")]
    FileAdded,
    #[serde(rename = "DEV_DEPENDENCY_OF")]
    DevDependencyOf,
    #[serde(rename = "DEPENDENCY_OF")]
    DependencyOf,
    #[serde(rename = "BUILD_DEPENDENCY_OF")]
    BuildDependencyOf,
    #[serde(rename = "DESCRIBES")]
    Describes,
    #[serde(rename = "PREREQUISITE_FOR")]
    PrerequisiteFor,
    #[serde(rename = "HAS_PREREQUISITE")]
    HasPrerequisite,
    #[serde(rename = "PROVIDED_DEPENDENCY_OF")]
    ProvidedDependencyOf,
    #[serde(rename = "DYNAMIC_LINK")]
    DynamicLink,
    #[serde(rename = "DESCRIBED_BY")]
    DescribedBy,
    #[serde(rename = "METAFILE_OF")]
    MetafileOf,
    #[serde(rename = "DEPENDENCY_MANIFEST_OF")]
    DependencyManifestOf,
    #[serde(rename = "PATCH_APPLIED")]
    PatchApplied,
    #[serde(rename = "RUNTIME_DEPENDENCY_OF")]
    RuntimeDependencyOf,
    #[serde(rename = "TEST_OF")]
    TestOf,
    #[serde(rename = "TEST_TOOL_OF")]
    TestToolOf,
    #[serde(rename = "DEPENDS_ON")]
    DependsOn,
    #[serde(rename = "FILE_MODIFIED")]
    FileModified,
    #[serde(rename = "DISTRIBUTION_ARTIFACT")]
    DistributionArtifact,
    #[serde(rename = "DOCUMENTATION_OF")]
    DocumentationOf,
    #[serde(rename = "GENERATED_FROM")]
    GeneratedFrom,
    #[serde(rename = "STATIC_LINK")]
    StaticLink,
    #[serde(rename = "OTHER")]
    Other,
    #[serde(rename = "BUILD_TOOL_OF")]
    BuildToolOf,
    #[serde(rename = "TEST_CASE_OF")]
    TestCaseOf,
    #[serde(rename = "PACKAGE_OF")]
    PackageOf,
    #[serde(rename = "DESCENDANT_OF")]
    DescendantOf,
    #[serde(rename = "FILE_DELETED")]
    FileDeleted,
    #[serde(rename = "EXPANDED_FROM_ARCHIVE")]
    ExpandedFromArchive,
    #[serde(rename = "DEV_TOOL_OF")]
    DevToolOf,
    #[serde(rename = "EXAMPLE_OF")]
    ExampleOf,
}
impl From<&Spdx22DocumentRelationshipsItemRelationshipType>
for Spdx22DocumentRelationshipsItemRelationshipType {
    fn from(value: &Spdx22DocumentRelationshipsItemRelationshipType) -> Self {
        value.clone()
    }
}
impl ToString for Spdx22DocumentRelationshipsItemRelationshipType {
    fn to_string(&self) -> String {
        match *self {
            Self::VariantOf => "VARIANT_OF".to_string(),
            Self::CopyOf => "COPY_OF".to_string(),
            Self::PatchFor => "PATCH_FOR".to_string(),
            Self::TestDependencyOf => "TEST_DEPENDENCY_OF".to_string(),
            Self::ContainedBy => "CONTAINED_BY".to_string(),
            Self::DataFileOf => "DATA_FILE_OF".to_string(),
            Self::OptionalComponentOf => "OPTIONAL_COMPONENT_OF".to_string(),
            Self::AncestorOf => "ANCESTOR_OF".to_string(),
            Self::Generates => "GENERATES".to_string(),
            Self::Contains => "CONTAINS".to_string(),
            Self::OptionalDependencyOf => "OPTIONAL_DEPENDENCY_OF".to_string(),
            Self::FileAdded => "FILE_ADDED".to_string(),
            Self::DevDependencyOf => "DEV_DEPENDENCY_OF".to_string(),
            Self::DependencyOf => "DEPENDENCY_OF".to_string(),
            Self::BuildDependencyOf => "BUILD_DEPENDENCY_OF".to_string(),
            Self::Describes => "DESCRIBES".to_string(),
            Self::PrerequisiteFor => "PREREQUISITE_FOR".to_string(),
            Self::HasPrerequisite => "HAS_PREREQUISITE".to_string(),
            Self::ProvidedDependencyOf => "PROVIDED_DEPENDENCY_OF".to_string(),
            Self::DynamicLink => "DYNAMIC_LINK".to_string(),
            Self::DescribedBy => "DESCRIBED_BY".to_string(),
            Self::MetafileOf => "METAFILE_OF".to_string(),
            Self::DependencyManifestOf => "DEPENDENCY_MANIFEST_OF".to_string(),
            Self::PatchApplied => "PATCH_APPLIED".to_string(),
            Self::RuntimeDependencyOf => "RUNTIME_DEPENDENCY_OF".to_string(),
            Self::TestOf => "TEST_OF".to_string(),
            Self::TestToolOf => "TEST_TOOL_OF".to_string(),
            Self::DependsOn => "DEPENDS_ON".to_string(),
            Self::FileModified => "FILE_MODIFIED".to_string(),
            Self::DistributionArtifact => "DISTRIBUTION_ARTIFACT".to_string(),
            Self::DocumentationOf => "DOCUMENTATION_OF".to_string(),
            Self::GeneratedFrom => "GENERATED_FROM".to_string(),
            Self::StaticLink => "STATIC_LINK".to_string(),
            Self::Other => "OTHER".to_string(),
            Self::BuildToolOf => "BUILD_TOOL_OF".to_string(),
            Self::TestCaseOf => "TEST_CASE_OF".to_string(),
            Self::PackageOf => "PACKAGE_OF".to_string(),
            Self::DescendantOf => "DESCENDANT_OF".to_string(),
            Self::FileDeleted => "FILE_DELETED".to_string(),
            Self::ExpandedFromArchive => "EXPANDED_FROM_ARCHIVE".to_string(),
            Self::DevToolOf => "DEV_TOOL_OF".to_string(),
            Self::ExampleOf => "EXAMPLE_OF".to_string(),
        }
    }
}
impl std::str::FromStr for Spdx22DocumentRelationshipsItemRelationshipType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "VARIANT_OF" => Ok(Self::VariantOf),
            "COPY_OF" => Ok(Self::CopyOf),
            "PATCH_FOR" => Ok(Self::PatchFor),
            "TEST_DEPENDENCY_OF" => Ok(Self::TestDependencyOf),
            "CONTAINED_BY" => Ok(Self::ContainedBy),
            "DATA_FILE_OF" => Ok(Self::DataFileOf),
            "OPTIONAL_COMPONENT_OF" => Ok(Self::OptionalComponentOf),
            "ANCESTOR_OF" => Ok(Self::AncestorOf),
            "GENERATES" => Ok(Self::Generates),
            "CONTAINS" => Ok(Self::Contains),
            "OPTIONAL_DEPENDENCY_OF" => Ok(Self::OptionalDependencyOf),
            "FILE_ADDED" => Ok(Self::FileAdded),
            "DEV_DEPENDENCY_OF" => Ok(Self::DevDependencyOf),
            "DEPENDENCY_OF" => Ok(Self::DependencyOf),
            "BUILD_DEPENDENCY_OF" => Ok(Self::BuildDependencyOf),
            "DESCRIBES" => Ok(Self::Describes),
            "PREREQUISITE_FOR" => Ok(Self::PrerequisiteFor),
            "HAS_PREREQUISITE" => Ok(Self::HasPrerequisite),
            "PROVIDED_DEPENDENCY_OF" => Ok(Self::ProvidedDependencyOf),
            "DYNAMIC_LINK" => Ok(Self::DynamicLink),
            "DESCRIBED_BY" => Ok(Self::DescribedBy),
            "METAFILE_OF" => Ok(Self::MetafileOf),
            "DEPENDENCY_MANIFEST_OF" => Ok(Self::DependencyManifestOf),
            "PATCH_APPLIED" => Ok(Self::PatchApplied),
            "RUNTIME_DEPENDENCY_OF" => Ok(Self::RuntimeDependencyOf),
            "TEST_OF" => Ok(Self::TestOf),
            "TEST_TOOL_OF" => Ok(Self::TestToolOf),
            "DEPENDS_ON" => Ok(Self::DependsOn),
            "FILE_MODIFIED" => Ok(Self::FileModified),
            "DISTRIBUTION_ARTIFACT" => Ok(Self::DistributionArtifact),
            "DOCUMENTATION_OF" => Ok(Self::DocumentationOf),
            "GENERATED_FROM" => Ok(Self::GeneratedFrom),
            "STATIC_LINK" => Ok(Self::StaticLink),
            "OTHER" => Ok(Self::Other),
            "BUILD_TOOL_OF" => Ok(Self::BuildToolOf),
            "TEST_CASE_OF" => Ok(Self::TestCaseOf),
            "PACKAGE_OF" => Ok(Self::PackageOf),
            "DESCENDANT_OF" => Ok(Self::DescendantOf),
            "FILE_DELETED" => Ok(Self::FileDeleted),
            "EXPANDED_FROM_ARCHIVE" => Ok(Self::ExpandedFromArchive),
            "DEV_TOOL_OF" => Ok(Self::DevToolOf),
            "EXAMPLE_OF" => Ok(Self::ExampleOf),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for Spdx22DocumentRelationshipsItemRelationshipType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for Spdx22DocumentRelationshipsItemRelationshipType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for Spdx22DocumentRelationshipsItemRelationshipType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct Spdx22DocumentReviewedsItem {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    ///The date and time at which the SpdxDocument was reviewed. This value must be in UTC and have 'Z' as its timezone indicator.
    #[serde(rename = "reviewDate", default, skip_serializing_if = "Option::is_none")]
    pub review_date: Option<String>,
    ///The name and, optionally, contact information of the person who performed the review. Values of this property must conform to the agent and tool syntax.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reviewer: Option<String>,
}
impl From<&Spdx22DocumentReviewedsItem> for Spdx22DocumentReviewedsItem {
    fn from(value: &Spdx22DocumentReviewedsItem) -> Self {
        value.clone()
    }
}
impl Spdx22DocumentReviewedsItem {
    pub fn builder() -> builder::Spdx22DocumentReviewedsItem {
        builder::Spdx22DocumentReviewedsItem::default()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct Spdx22DocumentSnippetsItem {
    ///Provide additional information about an SpdxElement.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub annotations: Vec<Spdx22DocumentSnippetsItemAnnotationsItem>,
    ///This field provides a place for the SPDX data creator to record acknowledgements that may be required to be communicated in some contexts. This is not meant to include theactual complete license text (see licenseConculded and licenseDeclared), and may or may not include copyright notices (see also copyrightText). The SPDX data creator may use this field to record other acknowledgements, such as particular clauses from license texts, which may be necessary or desirable to reproduce.
    #[serde(rename = "attributionTexts", default, skip_serializing_if = "Vec::is_empty")]
    pub attribution_texts: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    ///The text of copyright declarations recited in the Package or File.
    #[serde(rename = "copyrightText", default, skip_serializing_if = "Option::is_none")]
    pub copyright_text: Option<String>,
    ///The licenseComments property allows the preparer of the SPDX document to describe why the licensing in spdx:licenseConcluded was chosen.
    #[serde(
        rename = "licenseComments",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub license_comments: Option<String>,
    ///The licensing information that was discovered directly within the package. There will be an instance of this property for each distinct value of alllicenseInfoInFile properties of all files contained in the package.
    #[serde(
        rename = "licenseInfoFromFiles",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub license_info_from_files: Vec<String>,
    ///Licensing information that was discovered directly in the subject snippet. This is also considered a declared license for the snippet.
    #[serde(
        rename = "licenseInfoInSnippets",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub license_info_in_snippets: Vec<String>,
    ///Identify name of this SpdxElement.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    ///This field defines the byte range in the original host file (in X.2) that the snippet information applies to
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub ranges: Vec<Spdx22DocumentSnippetsItemRangesItem>,
    ///SPDX ID for File.  File containing the SPDX element (e.g. the file contaning a snippet).
    #[serde(
        rename = "snippetFromFile",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub snippet_from_file: Option<String>,
}
impl From<&Spdx22DocumentSnippetsItem> for Spdx22DocumentSnippetsItem {
    fn from(value: &Spdx22DocumentSnippetsItem) -> Self {
        value.clone()
    }
}
impl Spdx22DocumentSnippetsItem {
    pub fn builder() -> builder::Spdx22DocumentSnippetsItem {
        builder::Spdx22DocumentSnippetsItem::default()
    }
}
///An Annotation is a comment on an SpdxItem by an agent.
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct Spdx22DocumentSnippetsItemAnnotationsItem {
    ///Identify when the comment was made. This is to be specified according to the combined date and time in the UTC format, as specified in the ISO 8601 standard.
    #[serde(rename = "annotationDate", default, skip_serializing_if = "Option::is_none")]
    pub annotation_date: Option<String>,
    ///Type of the annotation.
    #[serde(rename = "annotationType", default, skip_serializing_if = "Option::is_none")]
    pub annotation_type: Option<Spdx22DocumentSnippetsItemAnnotationsItemAnnotationType>,
    ///This field identifies the person, organization or tool that has commented on a file, package, or the entire document.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotator: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
}
impl From<&Spdx22DocumentSnippetsItemAnnotationsItem>
for Spdx22DocumentSnippetsItemAnnotationsItem {
    fn from(value: &Spdx22DocumentSnippetsItemAnnotationsItem) -> Self {
        value.clone()
    }
}
impl Spdx22DocumentSnippetsItemAnnotationsItem {
    pub fn builder() -> builder::Spdx22DocumentSnippetsItemAnnotationsItem {
        builder::Spdx22DocumentSnippetsItemAnnotationsItem::default()
    }
}
///Type of the annotation.
#[derive(
    Clone,
    Copy,
    Debug,
    Deserialize,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
    Serialize,
    schemars::JsonSchema
)]
pub enum Spdx22DocumentSnippetsItemAnnotationsItemAnnotationType {
    #[serde(rename = "OTHER")]
    Other,
    #[serde(rename = "REVIEW")]
    Review,
}
impl From<&Spdx22DocumentSnippetsItemAnnotationsItemAnnotationType>
for Spdx22DocumentSnippetsItemAnnotationsItemAnnotationType {
    fn from(value: &Spdx22DocumentSnippetsItemAnnotationsItemAnnotationType) -> Self {
        value.clone()
    }
}
impl ToString for Spdx22DocumentSnippetsItemAnnotationsItemAnnotationType {
    fn to_string(&self) -> String {
        match *self {
            Self::Other => "OTHER".to_string(),
            Self::Review => "REVIEW".to_string(),
        }
    }
}
impl std::str::FromStr for Spdx22DocumentSnippetsItemAnnotationsItemAnnotationType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "OTHER" => Ok(Self::Other),
            "REVIEW" => Ok(Self::Review),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
for Spdx22DocumentSnippetsItemAnnotationsItemAnnotationType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
for Spdx22DocumentSnippetsItemAnnotationsItemAnnotationType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
for Spdx22DocumentSnippetsItemAnnotationsItemAnnotationType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct Spdx22DocumentSnippetsItemRangesItem {
    #[serde(rename = "endPointer", default, skip_serializing_if = "Option::is_none")]
    pub end_pointer: Option<Spdx22DocumentSnippetsItemRangesItemEndPointer>,
    #[serde(rename = "startPointer", default, skip_serializing_if = "Option::is_none")]
    pub start_pointer: Option<Spdx22DocumentSnippetsItemRangesItemStartPointer>,
}
impl From<&Spdx22DocumentSnippetsItemRangesItem>
for Spdx22DocumentSnippetsItemRangesItem {
    fn from(value: &Spdx22DocumentSnippetsItemRangesItem) -> Self {
        value.clone()
    }
}
impl Spdx22DocumentSnippetsItemRangesItem {
    pub fn builder() -> builder::Spdx22DocumentSnippetsItemRangesItem {
        builder::Spdx22DocumentSnippetsItemRangesItem::default()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct Spdx22DocumentSnippetsItemRangesItemEndPointer {
    ///SPDX ID for File
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reference: Option<String>,
}
impl From<&Spdx22DocumentSnippetsItemRangesItemEndPointer>
for Spdx22DocumentSnippetsItemRangesItemEndPointer {
    fn from(value: &Spdx22DocumentSnippetsItemRangesItemEndPointer) -> Self {
        value.clone()
    }
}
impl Spdx22DocumentSnippetsItemRangesItemEndPointer {
    pub fn builder() -> builder::Spdx22DocumentSnippetsItemRangesItemEndPointer {
        builder::Spdx22DocumentSnippetsItemRangesItemEndPointer::default()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, schemars::JsonSchema)]
pub struct Spdx22DocumentSnippetsItemRangesItemStartPointer {
    ///SPDX ID for File
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reference: Option<String>,
}
impl From<&Spdx22DocumentSnippetsItemRangesItemStartPointer>
for Spdx22DocumentSnippetsItemRangesItemStartPointer {
    fn from(value: &Spdx22DocumentSnippetsItemRangesItemStartPointer) -> Self {
        value.clone()
    }
}
impl Spdx22DocumentSnippetsItemRangesItemStartPointer {
    pub fn builder() -> builder::Spdx22DocumentSnippetsItemRangesItemStartPointer {
        builder::Spdx22DocumentSnippetsItemRangesItemStartPointer::default()
    }
}
pub mod builder {
    #[derive(Clone, Debug)]
    pub struct Spdx22 {
        document: Result<Option<super::Spdx22Document>, String>,
    }
    impl Default for Spdx22 {
        fn default() -> Self {
            Self {
                document: Ok(Default::default()),
            }
        }
    }
    impl Spdx22 {
        pub fn document<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::Spdx22Document>>,
            T::Error: std::fmt::Display,
        {
            self
                .document = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for document: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx22> for super::Spdx22 {
        type Error = String;
        fn try_from(value: Spdx22) -> Result<Self, String> {
            Ok(Self { document: value.document? })
        }
    }
    impl From<super::Spdx22> for Spdx22 {
        fn from(value: super::Spdx22) -> Self {
            Self {
                document: Ok(value.document),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx22Document {
        annotations: Result<Vec<super::Spdx22DocumentAnnotationsItem>, String>,
        comment: Result<Option<String>, String>,
        creation_info: Result<Option<super::Spdx22DocumentCreationInfo>, String>,
        data_license: Result<Option<String>, String>,
        describes_packages: Result<Vec<String>, String>,
        external_document_refs: Result<
            Vec<super::Spdx22DocumentExternalDocumentRefsItem>,
            String,
        >,
        files: Result<Vec<super::Spdx22DocumentFilesItem>, String>,
        has_extracted_licensing_infos: Result<
            Vec<super::Spdx22DocumentHasExtractedLicensingInfosItem>,
            String,
        >,
        name: Result<Option<String>, String>,
        packages: Result<Vec<super::Spdx22DocumentPackagesItem>, String>,
        relationships: Result<Vec<super::Spdx22DocumentRelationshipsItem>, String>,
        revieweds: Result<Vec<super::Spdx22DocumentReviewedsItem>, String>,
        snippets: Result<Vec<super::Spdx22DocumentSnippetsItem>, String>,
        spdx_version: Result<Option<String>, String>,
    }
    impl Default for Spdx22Document {
        fn default() -> Self {
            Self {
                annotations: Ok(Default::default()),
                comment: Ok(Default::default()),
                creation_info: Ok(Default::default()),
                data_license: Ok(Default::default()),
                describes_packages: Ok(Default::default()),
                external_document_refs: Ok(Default::default()),
                files: Ok(Default::default()),
                has_extracted_licensing_infos: Ok(Default::default()),
                name: Ok(Default::default()),
                packages: Ok(Default::default()),
                relationships: Ok(Default::default()),
                revieweds: Ok(Default::default()),
                snippets: Ok(Default::default()),
                spdx_version: Ok(Default::default()),
            }
        }
    }
    impl Spdx22Document {
        pub fn annotations<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Spdx22DocumentAnnotationsItem>>,
            T::Error: std::fmt::Display,
        {
            self
                .annotations = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for annotations: {}", e)
                });
            self
        }
        pub fn comment<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .comment = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for comment: {}", e)
                });
            self
        }
        pub fn creation_info<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::Spdx22DocumentCreationInfo>>,
            T::Error: std::fmt::Display,
        {
            self
                .creation_info = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for creation_info: {}", e)
                });
            self
        }
        pub fn data_license<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .data_license = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for data_license: {}", e)
                });
            self
        }
        pub fn describes_packages<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .describes_packages = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for describes_packages: {}", e
                    )
                });
            self
        }
        pub fn external_document_refs<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Spdx22DocumentExternalDocumentRefsItem>>,
            T::Error: std::fmt::Display,
        {
            self
                .external_document_refs = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for external_document_refs: {}",
                        e
                    )
                });
            self
        }
        pub fn files<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Spdx22DocumentFilesItem>>,
            T::Error: std::fmt::Display,
        {
            self
                .files = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for files: {}", e)
                });
            self
        }
        pub fn has_extracted_licensing_infos<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Vec<super::Spdx22DocumentHasExtractedLicensingInfosItem>,
            >,
            T::Error: std::fmt::Display,
        {
            self
                .has_extracted_licensing_infos = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for has_extracted_licensing_infos: {}",
                        e
                    )
                });
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn packages<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Spdx22DocumentPackagesItem>>,
            T::Error: std::fmt::Display,
        {
            self
                .packages = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for packages: {}", e)
                });
            self
        }
        pub fn relationships<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Spdx22DocumentRelationshipsItem>>,
            T::Error: std::fmt::Display,
        {
            self
                .relationships = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for relationships: {}", e)
                });
            self
        }
        pub fn revieweds<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Spdx22DocumentReviewedsItem>>,
            T::Error: std::fmt::Display,
        {
            self
                .revieweds = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for revieweds: {}", e)
                });
            self
        }
        pub fn snippets<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Spdx22DocumentSnippetsItem>>,
            T::Error: std::fmt::Display,
        {
            self
                .snippets = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for snippets: {}", e)
                });
            self
        }
        pub fn spdx_version<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .spdx_version = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for spdx_version: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx22Document> for super::Spdx22Document {
        type Error = String;
        fn try_from(value: Spdx22Document) -> Result<Self, String> {
            Ok(Self {
                annotations: value.annotations?,
                comment: value.comment?,
                creation_info: value.creation_info?,
                data_license: value.data_license?,
                describes_packages: value.describes_packages?,
                external_document_refs: value.external_document_refs?,
                files: value.files?,
                has_extracted_licensing_infos: value.has_extracted_licensing_infos?,
                name: value.name?,
                packages: value.packages?,
                relationships: value.relationships?,
                revieweds: value.revieweds?,
                snippets: value.snippets?,
                spdx_version: value.spdx_version?,
            })
        }
    }
    impl From<super::Spdx22Document> for Spdx22Document {
        fn from(value: super::Spdx22Document) -> Self {
            Self {
                annotations: Ok(value.annotations),
                comment: Ok(value.comment),
                creation_info: Ok(value.creation_info),
                data_license: Ok(value.data_license),
                describes_packages: Ok(value.describes_packages),
                external_document_refs: Ok(value.external_document_refs),
                files: Ok(value.files),
                has_extracted_licensing_infos: Ok(value.has_extracted_licensing_infos),
                name: Ok(value.name),
                packages: Ok(value.packages),
                relationships: Ok(value.relationships),
                revieweds: Ok(value.revieweds),
                snippets: Ok(value.snippets),
                spdx_version: Ok(value.spdx_version),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx22DocumentAnnotationsItem {
        annotation_date: Result<Option<String>, String>,
        annotation_type: Result<
            Option<super::Spdx22DocumentAnnotationsItemAnnotationType>,
            String,
        >,
        annotator: Result<Option<String>, String>,
        comment: Result<Option<String>, String>,
    }
    impl Default for Spdx22DocumentAnnotationsItem {
        fn default() -> Self {
            Self {
                annotation_date: Ok(Default::default()),
                annotation_type: Ok(Default::default()),
                annotator: Ok(Default::default()),
                comment: Ok(Default::default()),
            }
        }
    }
    impl Spdx22DocumentAnnotationsItem {
        pub fn annotation_date<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .annotation_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for annotation_date: {}", e)
                });
            self
        }
        pub fn annotation_type<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Option<super::Spdx22DocumentAnnotationsItemAnnotationType>,
            >,
            T::Error: std::fmt::Display,
        {
            self
                .annotation_type = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for annotation_type: {}", e)
                });
            self
        }
        pub fn annotator<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .annotator = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for annotator: {}", e)
                });
            self
        }
        pub fn comment<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .comment = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for comment: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx22DocumentAnnotationsItem>
    for super::Spdx22DocumentAnnotationsItem {
        type Error = String;
        fn try_from(value: Spdx22DocumentAnnotationsItem) -> Result<Self, String> {
            Ok(Self {
                annotation_date: value.annotation_date?,
                annotation_type: value.annotation_type?,
                annotator: value.annotator?,
                comment: value.comment?,
            })
        }
    }
    impl From<super::Spdx22DocumentAnnotationsItem> for Spdx22DocumentAnnotationsItem {
        fn from(value: super::Spdx22DocumentAnnotationsItem) -> Self {
            Self {
                annotation_date: Ok(value.annotation_date),
                annotation_type: Ok(value.annotation_type),
                annotator: Ok(value.annotator),
                comment: Ok(value.comment),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx22DocumentCreationInfo {
        comment: Result<Option<String>, String>,
        created: Result<Option<String>, String>,
        creators: Result<Vec<String>, String>,
        license_list_version: Result<Option<String>, String>,
    }
    impl Default for Spdx22DocumentCreationInfo {
        fn default() -> Self {
            Self {
                comment: Ok(Default::default()),
                created: Ok(Default::default()),
                creators: Ok(Default::default()),
                license_list_version: Ok(Default::default()),
            }
        }
    }
    impl Spdx22DocumentCreationInfo {
        pub fn comment<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .comment = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for comment: {}", e)
                });
            self
        }
        pub fn created<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .created = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for created: {}", e)
                });
            self
        }
        pub fn creators<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .creators = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for creators: {}", e)
                });
            self
        }
        pub fn license_list_version<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .license_list_version = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for license_list_version: {}", e
                    )
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx22DocumentCreationInfo>
    for super::Spdx22DocumentCreationInfo {
        type Error = String;
        fn try_from(value: Spdx22DocumentCreationInfo) -> Result<Self, String> {
            Ok(Self {
                comment: value.comment?,
                created: value.created?,
                creators: value.creators?,
                license_list_version: value.license_list_version?,
            })
        }
    }
    impl From<super::Spdx22DocumentCreationInfo> for Spdx22DocumentCreationInfo {
        fn from(value: super::Spdx22DocumentCreationInfo) -> Self {
            Self {
                comment: Ok(value.comment),
                created: Ok(value.created),
                creators: Ok(value.creators),
                license_list_version: Ok(value.license_list_version),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx22DocumentExternalDocumentRefsItem {
        checksum: Result<
            Option<super::Spdx22DocumentExternalDocumentRefsItemChecksum>,
            String,
        >,
        external_document_id: Result<Option<String>, String>,
        spdx_document: Result<Option<String>, String>,
    }
    impl Default for Spdx22DocumentExternalDocumentRefsItem {
        fn default() -> Self {
            Self {
                checksum: Ok(Default::default()),
                external_document_id: Ok(Default::default()),
                spdx_document: Ok(Default::default()),
            }
        }
    }
    impl Spdx22DocumentExternalDocumentRefsItem {
        pub fn checksum<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Option<super::Spdx22DocumentExternalDocumentRefsItemChecksum>,
            >,
            T::Error: std::fmt::Display,
        {
            self
                .checksum = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for checksum: {}", e)
                });
            self
        }
        pub fn external_document_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .external_document_id = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for external_document_id: {}", e
                    )
                });
            self
        }
        pub fn spdx_document<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .spdx_document = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for spdx_document: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx22DocumentExternalDocumentRefsItem>
    for super::Spdx22DocumentExternalDocumentRefsItem {
        type Error = String;
        fn try_from(
            value: Spdx22DocumentExternalDocumentRefsItem,
        ) -> Result<Self, String> {
            Ok(Self {
                checksum: value.checksum?,
                external_document_id: value.external_document_id?,
                spdx_document: value.spdx_document?,
            })
        }
    }
    impl From<super::Spdx22DocumentExternalDocumentRefsItem>
    for Spdx22DocumentExternalDocumentRefsItem {
        fn from(value: super::Spdx22DocumentExternalDocumentRefsItem) -> Self {
            Self {
                checksum: Ok(value.checksum),
                external_document_id: Ok(value.external_document_id),
                spdx_document: Ok(value.spdx_document),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx22DocumentExternalDocumentRefsItemChecksum {
        algorithm: Result<
            Option<super::Spdx22DocumentExternalDocumentRefsItemChecksumAlgorithm>,
            String,
        >,
        checksum_value: Result<Option<String>, String>,
    }
    impl Default for Spdx22DocumentExternalDocumentRefsItemChecksum {
        fn default() -> Self {
            Self {
                algorithm: Ok(Default::default()),
                checksum_value: Ok(Default::default()),
            }
        }
    }
    impl Spdx22DocumentExternalDocumentRefsItemChecksum {
        pub fn algorithm<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Option<super::Spdx22DocumentExternalDocumentRefsItemChecksumAlgorithm>,
            >,
            T::Error: std::fmt::Display,
        {
            self
                .algorithm = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for algorithm: {}", e)
                });
            self
        }
        pub fn checksum_value<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .checksum_value = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for checksum_value: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx22DocumentExternalDocumentRefsItemChecksum>
    for super::Spdx22DocumentExternalDocumentRefsItemChecksum {
        type Error = String;
        fn try_from(
            value: Spdx22DocumentExternalDocumentRefsItemChecksum,
        ) -> Result<Self, String> {
            Ok(Self {
                algorithm: value.algorithm?,
                checksum_value: value.checksum_value?,
            })
        }
    }
    impl From<super::Spdx22DocumentExternalDocumentRefsItemChecksum>
    for Spdx22DocumentExternalDocumentRefsItemChecksum {
        fn from(value: super::Spdx22DocumentExternalDocumentRefsItemChecksum) -> Self {
            Self {
                algorithm: Ok(value.algorithm),
                checksum_value: Ok(value.checksum_value),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx22DocumentFilesItem {
        annotations: Result<Vec<super::Spdx22DocumentFilesItemAnnotationsItem>, String>,
        artifact_ofs: Result<
            Vec<std::collections::HashMap<String, serde_json::Value>>,
            String,
        >,
        attribution_texts: Result<Vec<String>, String>,
        checksums: Result<Vec<super::Spdx22DocumentFilesItemChecksumsItem>, String>,
        comment: Result<Option<String>, String>,
        copyright_text: Result<Option<String>, String>,
        file_contributors: Result<Vec<String>, String>,
        file_dependencies: Result<Vec<String>, String>,
        file_name: Result<Option<String>, String>,
        file_types: Result<Vec<super::Spdx22DocumentFilesItemFileTypesItem>, String>,
        license_comments: Result<Option<String>, String>,
        license_info_from_files: Result<Vec<String>, String>,
        license_info_in_files: Result<Vec<String>, String>,
        name: Result<Option<String>, String>,
        notice_text: Result<Option<String>, String>,
    }
    impl Default for Spdx22DocumentFilesItem {
        fn default() -> Self {
            Self {
                annotations: Ok(Default::default()),
                artifact_ofs: Ok(Default::default()),
                attribution_texts: Ok(Default::default()),
                checksums: Ok(Default::default()),
                comment: Ok(Default::default()),
                copyright_text: Ok(Default::default()),
                file_contributors: Ok(Default::default()),
                file_dependencies: Ok(Default::default()),
                file_name: Ok(Default::default()),
                file_types: Ok(Default::default()),
                license_comments: Ok(Default::default()),
                license_info_from_files: Ok(Default::default()),
                license_info_in_files: Ok(Default::default()),
                name: Ok(Default::default()),
                notice_text: Ok(Default::default()),
            }
        }
    }
    impl Spdx22DocumentFilesItem {
        pub fn annotations<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Spdx22DocumentFilesItemAnnotationsItem>>,
            T::Error: std::fmt::Display,
        {
            self
                .annotations = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for annotations: {}", e)
                });
            self
        }
        pub fn artifact_ofs<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Vec<std::collections::HashMap<String, serde_json::Value>>,
            >,
            T::Error: std::fmt::Display,
        {
            self
                .artifact_ofs = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for artifact_ofs: {}", e)
                });
            self
        }
        pub fn attribution_texts<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .attribution_texts = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for attribution_texts: {}", e
                    )
                });
            self
        }
        pub fn checksums<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Spdx22DocumentFilesItemChecksumsItem>>,
            T::Error: std::fmt::Display,
        {
            self
                .checksums = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for checksums: {}", e)
                });
            self
        }
        pub fn comment<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .comment = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for comment: {}", e)
                });
            self
        }
        pub fn copyright_text<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .copyright_text = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for copyright_text: {}", e)
                });
            self
        }
        pub fn file_contributors<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .file_contributors = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for file_contributors: {}", e
                    )
                });
            self
        }
        pub fn file_dependencies<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .file_dependencies = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for file_dependencies: {}", e
                    )
                });
            self
        }
        pub fn file_name<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .file_name = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for file_name: {}", e)
                });
            self
        }
        pub fn file_types<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Spdx22DocumentFilesItemFileTypesItem>>,
            T::Error: std::fmt::Display,
        {
            self
                .file_types = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for file_types: {}", e)
                });
            self
        }
        pub fn license_comments<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .license_comments = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for license_comments: {}", e
                    )
                });
            self
        }
        pub fn license_info_from_files<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .license_info_from_files = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for license_info_from_files: {}",
                        e
                    )
                });
            self
        }
        pub fn license_info_in_files<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .license_info_in_files = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for license_info_in_files: {}",
                        e
                    )
                });
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn notice_text<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .notice_text = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for notice_text: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx22DocumentFilesItem>
    for super::Spdx22DocumentFilesItem {
        type Error = String;
        fn try_from(value: Spdx22DocumentFilesItem) -> Result<Self, String> {
            Ok(Self {
                annotations: value.annotations?,
                artifact_ofs: value.artifact_ofs?,
                attribution_texts: value.attribution_texts?,
                checksums: value.checksums?,
                comment: value.comment?,
                copyright_text: value.copyright_text?,
                file_contributors: value.file_contributors?,
                file_dependencies: value.file_dependencies?,
                file_name: value.file_name?,
                file_types: value.file_types?,
                license_comments: value.license_comments?,
                license_info_from_files: value.license_info_from_files?,
                license_info_in_files: value.license_info_in_files?,
                name: value.name?,
                notice_text: value.notice_text?,
            })
        }
    }
    impl From<super::Spdx22DocumentFilesItem> for Spdx22DocumentFilesItem {
        fn from(value: super::Spdx22DocumentFilesItem) -> Self {
            Self {
                annotations: Ok(value.annotations),
                artifact_ofs: Ok(value.artifact_ofs),
                attribution_texts: Ok(value.attribution_texts),
                checksums: Ok(value.checksums),
                comment: Ok(value.comment),
                copyright_text: Ok(value.copyright_text),
                file_contributors: Ok(value.file_contributors),
                file_dependencies: Ok(value.file_dependencies),
                file_name: Ok(value.file_name),
                file_types: Ok(value.file_types),
                license_comments: Ok(value.license_comments),
                license_info_from_files: Ok(value.license_info_from_files),
                license_info_in_files: Ok(value.license_info_in_files),
                name: Ok(value.name),
                notice_text: Ok(value.notice_text),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx22DocumentFilesItemAnnotationsItem {
        annotation_date: Result<Option<String>, String>,
        annotation_type: Result<
            Option<super::Spdx22DocumentFilesItemAnnotationsItemAnnotationType>,
            String,
        >,
        annotator: Result<Option<String>, String>,
        comment: Result<Option<String>, String>,
    }
    impl Default for Spdx22DocumentFilesItemAnnotationsItem {
        fn default() -> Self {
            Self {
                annotation_date: Ok(Default::default()),
                annotation_type: Ok(Default::default()),
                annotator: Ok(Default::default()),
                comment: Ok(Default::default()),
            }
        }
    }
    impl Spdx22DocumentFilesItemAnnotationsItem {
        pub fn annotation_date<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .annotation_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for annotation_date: {}", e)
                });
            self
        }
        pub fn annotation_type<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Option<super::Spdx22DocumentFilesItemAnnotationsItemAnnotationType>,
            >,
            T::Error: std::fmt::Display,
        {
            self
                .annotation_type = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for annotation_type: {}", e)
                });
            self
        }
        pub fn annotator<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .annotator = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for annotator: {}", e)
                });
            self
        }
        pub fn comment<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .comment = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for comment: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx22DocumentFilesItemAnnotationsItem>
    for super::Spdx22DocumentFilesItemAnnotationsItem {
        type Error = String;
        fn try_from(
            value: Spdx22DocumentFilesItemAnnotationsItem,
        ) -> Result<Self, String> {
            Ok(Self {
                annotation_date: value.annotation_date?,
                annotation_type: value.annotation_type?,
                annotator: value.annotator?,
                comment: value.comment?,
            })
        }
    }
    impl From<super::Spdx22DocumentFilesItemAnnotationsItem>
    for Spdx22DocumentFilesItemAnnotationsItem {
        fn from(value: super::Spdx22DocumentFilesItemAnnotationsItem) -> Self {
            Self {
                annotation_date: Ok(value.annotation_date),
                annotation_type: Ok(value.annotation_type),
                annotator: Ok(value.annotator),
                comment: Ok(value.comment),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx22DocumentFilesItemChecksumsItem {
        algorithm: Result<
            Option<super::Spdx22DocumentFilesItemChecksumsItemAlgorithm>,
            String,
        >,
        checksum_value: Result<Option<String>, String>,
    }
    impl Default for Spdx22DocumentFilesItemChecksumsItem {
        fn default() -> Self {
            Self {
                algorithm: Ok(Default::default()),
                checksum_value: Ok(Default::default()),
            }
        }
    }
    impl Spdx22DocumentFilesItemChecksumsItem {
        pub fn algorithm<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Option<super::Spdx22DocumentFilesItemChecksumsItemAlgorithm>,
            >,
            T::Error: std::fmt::Display,
        {
            self
                .algorithm = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for algorithm: {}", e)
                });
            self
        }
        pub fn checksum_value<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .checksum_value = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for checksum_value: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx22DocumentFilesItemChecksumsItem>
    for super::Spdx22DocumentFilesItemChecksumsItem {
        type Error = String;
        fn try_from(
            value: Spdx22DocumentFilesItemChecksumsItem,
        ) -> Result<Self, String> {
            Ok(Self {
                algorithm: value.algorithm?,
                checksum_value: value.checksum_value?,
            })
        }
    }
    impl From<super::Spdx22DocumentFilesItemChecksumsItem>
    for Spdx22DocumentFilesItemChecksumsItem {
        fn from(value: super::Spdx22DocumentFilesItemChecksumsItem) -> Self {
            Self {
                algorithm: Ok(value.algorithm),
                checksum_value: Ok(value.checksum_value),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx22DocumentHasExtractedLicensingInfosItem {
        comment: Result<Option<String>, String>,
        extracted_text: Result<Option<String>, String>,
        license_id: Result<Option<String>, String>,
        name: Result<Option<String>, String>,
        see_alsos: Result<Vec<String>, String>,
    }
    impl Default for Spdx22DocumentHasExtractedLicensingInfosItem {
        fn default() -> Self {
            Self {
                comment: Ok(Default::default()),
                extracted_text: Ok(Default::default()),
                license_id: Ok(Default::default()),
                name: Ok(Default::default()),
                see_alsos: Ok(Default::default()),
            }
        }
    }
    impl Spdx22DocumentHasExtractedLicensingInfosItem {
        pub fn comment<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .comment = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for comment: {}", e)
                });
            self
        }
        pub fn extracted_text<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .extracted_text = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for extracted_text: {}", e)
                });
            self
        }
        pub fn license_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .license_id = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for license_id: {}", e)
                });
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn see_alsos<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .see_alsos = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for see_alsos: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx22DocumentHasExtractedLicensingInfosItem>
    for super::Spdx22DocumentHasExtractedLicensingInfosItem {
        type Error = String;
        fn try_from(
            value: Spdx22DocumentHasExtractedLicensingInfosItem,
        ) -> Result<Self, String> {
            Ok(Self {
                comment: value.comment?,
                extracted_text: value.extracted_text?,
                license_id: value.license_id?,
                name: value.name?,
                see_alsos: value.see_alsos?,
            })
        }
    }
    impl From<super::Spdx22DocumentHasExtractedLicensingInfosItem>
    for Spdx22DocumentHasExtractedLicensingInfosItem {
        fn from(value: super::Spdx22DocumentHasExtractedLicensingInfosItem) -> Self {
            Self {
                comment: Ok(value.comment),
                extracted_text: Ok(value.extracted_text),
                license_id: Ok(value.license_id),
                name: Ok(value.name),
                see_alsos: Ok(value.see_alsos),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx22DocumentPackagesItem {
        annotations: Result<
            Vec<super::Spdx22DocumentPackagesItemAnnotationsItem>,
            String,
        >,
        attribution_texts: Result<Vec<String>, String>,
        checksums: Result<Vec<super::Spdx22DocumentPackagesItemChecksumsItem>, String>,
        comment: Result<Option<String>, String>,
        copyright_text: Result<Option<String>, String>,
        description: Result<Option<String>, String>,
        download_location: Result<Option<String>, String>,
        external_refs: Result<
            Vec<super::Spdx22DocumentPackagesItemExternalRefsItem>,
            String,
        >,
        files_analyzed: Result<Option<bool>, String>,
        has_files: Result<Vec<String>, String>,
        homepage: Result<Option<String>, String>,
        license_comments: Result<Option<String>, String>,
        license_info_from_files: Result<Vec<String>, String>,
        name: Result<Option<String>, String>,
        originator: Result<Option<String>, String>,
        package_file_name: Result<Option<String>, String>,
        package_verification_code: Result<
            Option<super::Spdx22DocumentPackagesItemPackageVerificationCode>,
            String,
        >,
        source_info: Result<Option<String>, String>,
        summary: Result<Option<String>, String>,
        supplier: Result<Option<String>, String>,
        version_info: Result<Option<String>, String>,
    }
    impl Default for Spdx22DocumentPackagesItem {
        fn default() -> Self {
            Self {
                annotations: Ok(Default::default()),
                attribution_texts: Ok(Default::default()),
                checksums: Ok(Default::default()),
                comment: Ok(Default::default()),
                copyright_text: Ok(Default::default()),
                description: Ok(Default::default()),
                download_location: Ok(Default::default()),
                external_refs: Ok(Default::default()),
                files_analyzed: Ok(Default::default()),
                has_files: Ok(Default::default()),
                homepage: Ok(Default::default()),
                license_comments: Ok(Default::default()),
                license_info_from_files: Ok(Default::default()),
                name: Ok(Default::default()),
                originator: Ok(Default::default()),
                package_file_name: Ok(Default::default()),
                package_verification_code: Ok(Default::default()),
                source_info: Ok(Default::default()),
                summary: Ok(Default::default()),
                supplier: Ok(Default::default()),
                version_info: Ok(Default::default()),
            }
        }
    }
    impl Spdx22DocumentPackagesItem {
        pub fn annotations<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Vec<super::Spdx22DocumentPackagesItemAnnotationsItem>,
            >,
            T::Error: std::fmt::Display,
        {
            self
                .annotations = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for annotations: {}", e)
                });
            self
        }
        pub fn attribution_texts<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .attribution_texts = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for attribution_texts: {}", e
                    )
                });
            self
        }
        pub fn checksums<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Vec<super::Spdx22DocumentPackagesItemChecksumsItem>,
            >,
            T::Error: std::fmt::Display,
        {
            self
                .checksums = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for checksums: {}", e)
                });
            self
        }
        pub fn comment<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .comment = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for comment: {}", e)
                });
            self
        }
        pub fn copyright_text<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .copyright_text = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for copyright_text: {}", e)
                });
            self
        }
        pub fn description<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .description = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for description: {}", e)
                });
            self
        }
        pub fn download_location<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .download_location = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for download_location: {}", e
                    )
                });
            self
        }
        pub fn external_refs<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Vec<super::Spdx22DocumentPackagesItemExternalRefsItem>,
            >,
            T::Error: std::fmt::Display,
        {
            self
                .external_refs = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for external_refs: {}", e)
                });
            self
        }
        pub fn files_analyzed<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<bool>>,
            T::Error: std::fmt::Display,
        {
            self
                .files_analyzed = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for files_analyzed: {}", e)
                });
            self
        }
        pub fn has_files<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .has_files = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for has_files: {}", e)
                });
            self
        }
        pub fn homepage<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .homepage = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for homepage: {}", e)
                });
            self
        }
        pub fn license_comments<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .license_comments = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for license_comments: {}", e
                    )
                });
            self
        }
        pub fn license_info_from_files<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .license_info_from_files = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for license_info_from_files: {}",
                        e
                    )
                });
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn originator<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .originator = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for originator: {}", e)
                });
            self
        }
        pub fn package_file_name<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .package_file_name = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for package_file_name: {}", e
                    )
                });
            self
        }
        pub fn package_verification_code<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Option<super::Spdx22DocumentPackagesItemPackageVerificationCode>,
            >,
            T::Error: std::fmt::Display,
        {
            self
                .package_verification_code = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for package_verification_code: {}",
                        e
                    )
                });
            self
        }
        pub fn source_info<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .source_info = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for source_info: {}", e)
                });
            self
        }
        pub fn summary<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .summary = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for summary: {}", e)
                });
            self
        }
        pub fn supplier<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .supplier = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for supplier: {}", e)
                });
            self
        }
        pub fn version_info<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .version_info = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for version_info: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx22DocumentPackagesItem>
    for super::Spdx22DocumentPackagesItem {
        type Error = String;
        fn try_from(value: Spdx22DocumentPackagesItem) -> Result<Self, String> {
            Ok(Self {
                annotations: value.annotations?,
                attribution_texts: value.attribution_texts?,
                checksums: value.checksums?,
                comment: value.comment?,
                copyright_text: value.copyright_text?,
                description: value.description?,
                download_location: value.download_location?,
                external_refs: value.external_refs?,
                files_analyzed: value.files_analyzed?,
                has_files: value.has_files?,
                homepage: value.homepage?,
                license_comments: value.license_comments?,
                license_info_from_files: value.license_info_from_files?,
                name: value.name?,
                originator: value.originator?,
                package_file_name: value.package_file_name?,
                package_verification_code: value.package_verification_code?,
                source_info: value.source_info?,
                summary: value.summary?,
                supplier: value.supplier?,
                version_info: value.version_info?,
            })
        }
    }
    impl From<super::Spdx22DocumentPackagesItem> for Spdx22DocumentPackagesItem {
        fn from(value: super::Spdx22DocumentPackagesItem) -> Self {
            Self {
                annotations: Ok(value.annotations),
                attribution_texts: Ok(value.attribution_texts),
                checksums: Ok(value.checksums),
                comment: Ok(value.comment),
                copyright_text: Ok(value.copyright_text),
                description: Ok(value.description),
                download_location: Ok(value.download_location),
                external_refs: Ok(value.external_refs),
                files_analyzed: Ok(value.files_analyzed),
                has_files: Ok(value.has_files),
                homepage: Ok(value.homepage),
                license_comments: Ok(value.license_comments),
                license_info_from_files: Ok(value.license_info_from_files),
                name: Ok(value.name),
                originator: Ok(value.originator),
                package_file_name: Ok(value.package_file_name),
                package_verification_code: Ok(value.package_verification_code),
                source_info: Ok(value.source_info),
                summary: Ok(value.summary),
                supplier: Ok(value.supplier),
                version_info: Ok(value.version_info),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx22DocumentPackagesItemAnnotationsItem {
        annotation_date: Result<Option<String>, String>,
        annotation_type: Result<
            Option<super::Spdx22DocumentPackagesItemAnnotationsItemAnnotationType>,
            String,
        >,
        annotator: Result<Option<String>, String>,
        comment: Result<Option<String>, String>,
    }
    impl Default for Spdx22DocumentPackagesItemAnnotationsItem {
        fn default() -> Self {
            Self {
                annotation_date: Ok(Default::default()),
                annotation_type: Ok(Default::default()),
                annotator: Ok(Default::default()),
                comment: Ok(Default::default()),
            }
        }
    }
    impl Spdx22DocumentPackagesItemAnnotationsItem {
        pub fn annotation_date<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .annotation_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for annotation_date: {}", e)
                });
            self
        }
        pub fn annotation_type<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Option<super::Spdx22DocumentPackagesItemAnnotationsItemAnnotationType>,
            >,
            T::Error: std::fmt::Display,
        {
            self
                .annotation_type = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for annotation_type: {}", e)
                });
            self
        }
        pub fn annotator<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .annotator = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for annotator: {}", e)
                });
            self
        }
        pub fn comment<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .comment = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for comment: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx22DocumentPackagesItemAnnotationsItem>
    for super::Spdx22DocumentPackagesItemAnnotationsItem {
        type Error = String;
        fn try_from(
            value: Spdx22DocumentPackagesItemAnnotationsItem,
        ) -> Result<Self, String> {
            Ok(Self {
                annotation_date: value.annotation_date?,
                annotation_type: value.annotation_type?,
                annotator: value.annotator?,
                comment: value.comment?,
            })
        }
    }
    impl From<super::Spdx22DocumentPackagesItemAnnotationsItem>
    for Spdx22DocumentPackagesItemAnnotationsItem {
        fn from(value: super::Spdx22DocumentPackagesItemAnnotationsItem) -> Self {
            Self {
                annotation_date: Ok(value.annotation_date),
                annotation_type: Ok(value.annotation_type),
                annotator: Ok(value.annotator),
                comment: Ok(value.comment),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx22DocumentPackagesItemChecksumsItem {
        algorithm: Result<
            Option<super::Spdx22DocumentPackagesItemChecksumsItemAlgorithm>,
            String,
        >,
        checksum_value: Result<Option<String>, String>,
    }
    impl Default for Spdx22DocumentPackagesItemChecksumsItem {
        fn default() -> Self {
            Self {
                algorithm: Ok(Default::default()),
                checksum_value: Ok(Default::default()),
            }
        }
    }
    impl Spdx22DocumentPackagesItemChecksumsItem {
        pub fn algorithm<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Option<super::Spdx22DocumentPackagesItemChecksumsItemAlgorithm>,
            >,
            T::Error: std::fmt::Display,
        {
            self
                .algorithm = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for algorithm: {}", e)
                });
            self
        }
        pub fn checksum_value<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .checksum_value = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for checksum_value: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx22DocumentPackagesItemChecksumsItem>
    for super::Spdx22DocumentPackagesItemChecksumsItem {
        type Error = String;
        fn try_from(
            value: Spdx22DocumentPackagesItemChecksumsItem,
        ) -> Result<Self, String> {
            Ok(Self {
                algorithm: value.algorithm?,
                checksum_value: value.checksum_value?,
            })
        }
    }
    impl From<super::Spdx22DocumentPackagesItemChecksumsItem>
    for Spdx22DocumentPackagesItemChecksumsItem {
        fn from(value: super::Spdx22DocumentPackagesItemChecksumsItem) -> Self {
            Self {
                algorithm: Ok(value.algorithm),
                checksum_value: Ok(value.checksum_value),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx22DocumentPackagesItemExternalRefsItem {
        comment: Result<Option<String>, String>,
        reference_category: Result<
            Option<super::Spdx22DocumentPackagesItemExternalRefsItemReferenceCategory>,
            String,
        >,
        reference_locator: Result<Option<String>, String>,
        reference_type: Result<Option<String>, String>,
    }
    impl Default for Spdx22DocumentPackagesItemExternalRefsItem {
        fn default() -> Self {
            Self {
                comment: Ok(Default::default()),
                reference_category: Ok(Default::default()),
                reference_locator: Ok(Default::default()),
                reference_type: Ok(Default::default()),
            }
        }
    }
    impl Spdx22DocumentPackagesItemExternalRefsItem {
        pub fn comment<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .comment = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for comment: {}", e)
                });
            self
        }
        pub fn reference_category<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Option<
                    super::Spdx22DocumentPackagesItemExternalRefsItemReferenceCategory,
                >,
            >,
            T::Error: std::fmt::Display,
        {
            self
                .reference_category = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for reference_category: {}", e
                    )
                });
            self
        }
        pub fn reference_locator<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .reference_locator = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for reference_locator: {}", e
                    )
                });
            self
        }
        pub fn reference_type<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .reference_type = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for reference_type: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx22DocumentPackagesItemExternalRefsItem>
    for super::Spdx22DocumentPackagesItemExternalRefsItem {
        type Error = String;
        fn try_from(
            value: Spdx22DocumentPackagesItemExternalRefsItem,
        ) -> Result<Self, String> {
            Ok(Self {
                comment: value.comment?,
                reference_category: value.reference_category?,
                reference_locator: value.reference_locator?,
                reference_type: value.reference_type?,
            })
        }
    }
    impl From<super::Spdx22DocumentPackagesItemExternalRefsItem>
    for Spdx22DocumentPackagesItemExternalRefsItem {
        fn from(value: super::Spdx22DocumentPackagesItemExternalRefsItem) -> Self {
            Self {
                comment: Ok(value.comment),
                reference_category: Ok(value.reference_category),
                reference_locator: Ok(value.reference_locator),
                reference_type: Ok(value.reference_type),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx22DocumentPackagesItemPackageVerificationCode {
        package_verification_code_excluded_files: Result<Vec<String>, String>,
        package_verification_code_value: Result<Option<String>, String>,
    }
    impl Default for Spdx22DocumentPackagesItemPackageVerificationCode {
        fn default() -> Self {
            Self {
                package_verification_code_excluded_files: Ok(Default::default()),
                package_verification_code_value: Ok(Default::default()),
            }
        }
    }
    impl Spdx22DocumentPackagesItemPackageVerificationCode {
        pub fn package_verification_code_excluded_files<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .package_verification_code_excluded_files = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for package_verification_code_excluded_files: {}",
                        e
                    )
                });
            self
        }
        pub fn package_verification_code_value<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .package_verification_code_value = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for package_verification_code_value: {}",
                        e
                    )
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx22DocumentPackagesItemPackageVerificationCode>
    for super::Spdx22DocumentPackagesItemPackageVerificationCode {
        type Error = String;
        fn try_from(
            value: Spdx22DocumentPackagesItemPackageVerificationCode,
        ) -> Result<Self, String> {
            Ok(Self {
                package_verification_code_excluded_files: value
                    .package_verification_code_excluded_files?,
                package_verification_code_value: value.package_verification_code_value?,
            })
        }
    }
    impl From<super::Spdx22DocumentPackagesItemPackageVerificationCode>
    for Spdx22DocumentPackagesItemPackageVerificationCode {
        fn from(
            value: super::Spdx22DocumentPackagesItemPackageVerificationCode,
        ) -> Self {
            Self {
                package_verification_code_excluded_files: Ok(
                    value.package_verification_code_excluded_files,
                ),
                package_verification_code_value: Ok(
                    value.package_verification_code_value,
                ),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx22DocumentRelationshipsItem {
        comment: Result<Option<String>, String>,
        related_spdx_element: Result<Option<String>, String>,
        relationship_type: Result<
            Option<super::Spdx22DocumentRelationshipsItemRelationshipType>,
            String,
        >,
    }
    impl Default for Spdx22DocumentRelationshipsItem {
        fn default() -> Self {
            Self {
                comment: Ok(Default::default()),
                related_spdx_element: Ok(Default::default()),
                relationship_type: Ok(Default::default()),
            }
        }
    }
    impl Spdx22DocumentRelationshipsItem {
        pub fn comment<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .comment = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for comment: {}", e)
                });
            self
        }
        pub fn related_spdx_element<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .related_spdx_element = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for related_spdx_element: {}", e
                    )
                });
            self
        }
        pub fn relationship_type<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Option<super::Spdx22DocumentRelationshipsItemRelationshipType>,
            >,
            T::Error: std::fmt::Display,
        {
            self
                .relationship_type = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for relationship_type: {}", e
                    )
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx22DocumentRelationshipsItem>
    for super::Spdx22DocumentRelationshipsItem {
        type Error = String;
        fn try_from(value: Spdx22DocumentRelationshipsItem) -> Result<Self, String> {
            Ok(Self {
                comment: value.comment?,
                related_spdx_element: value.related_spdx_element?,
                relationship_type: value.relationship_type?,
            })
        }
    }
    impl From<super::Spdx22DocumentRelationshipsItem>
    for Spdx22DocumentRelationshipsItem {
        fn from(value: super::Spdx22DocumentRelationshipsItem) -> Self {
            Self {
                comment: Ok(value.comment),
                related_spdx_element: Ok(value.related_spdx_element),
                relationship_type: Ok(value.relationship_type),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx22DocumentReviewedsItem {
        comment: Result<Option<String>, String>,
        review_date: Result<Option<String>, String>,
        reviewer: Result<Option<String>, String>,
    }
    impl Default for Spdx22DocumentReviewedsItem {
        fn default() -> Self {
            Self {
                comment: Ok(Default::default()),
                review_date: Ok(Default::default()),
                reviewer: Ok(Default::default()),
            }
        }
    }
    impl Spdx22DocumentReviewedsItem {
        pub fn comment<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .comment = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for comment: {}", e)
                });
            self
        }
        pub fn review_date<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .review_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for review_date: {}", e)
                });
            self
        }
        pub fn reviewer<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .reviewer = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for reviewer: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx22DocumentReviewedsItem>
    for super::Spdx22DocumentReviewedsItem {
        type Error = String;
        fn try_from(value: Spdx22DocumentReviewedsItem) -> Result<Self, String> {
            Ok(Self {
                comment: value.comment?,
                review_date: value.review_date?,
                reviewer: value.reviewer?,
            })
        }
    }
    impl From<super::Spdx22DocumentReviewedsItem> for Spdx22DocumentReviewedsItem {
        fn from(value: super::Spdx22DocumentReviewedsItem) -> Self {
            Self {
                comment: Ok(value.comment),
                review_date: Ok(value.review_date),
                reviewer: Ok(value.reviewer),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx22DocumentSnippetsItem {
        annotations: Result<
            Vec<super::Spdx22DocumentSnippetsItemAnnotationsItem>,
            String,
        >,
        attribution_texts: Result<Vec<String>, String>,
        comment: Result<Option<String>, String>,
        copyright_text: Result<Option<String>, String>,
        license_comments: Result<Option<String>, String>,
        license_info_from_files: Result<Vec<String>, String>,
        license_info_in_snippets: Result<Vec<String>, String>,
        name: Result<Option<String>, String>,
        ranges: Result<Vec<super::Spdx22DocumentSnippetsItemRangesItem>, String>,
        snippet_from_file: Result<Option<String>, String>,
    }
    impl Default for Spdx22DocumentSnippetsItem {
        fn default() -> Self {
            Self {
                annotations: Ok(Default::default()),
                attribution_texts: Ok(Default::default()),
                comment: Ok(Default::default()),
                copyright_text: Ok(Default::default()),
                license_comments: Ok(Default::default()),
                license_info_from_files: Ok(Default::default()),
                license_info_in_snippets: Ok(Default::default()),
                name: Ok(Default::default()),
                ranges: Ok(Default::default()),
                snippet_from_file: Ok(Default::default()),
            }
        }
    }
    impl Spdx22DocumentSnippetsItem {
        pub fn annotations<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Vec<super::Spdx22DocumentSnippetsItemAnnotationsItem>,
            >,
            T::Error: std::fmt::Display,
        {
            self
                .annotations = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for annotations: {}", e)
                });
            self
        }
        pub fn attribution_texts<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .attribution_texts = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for attribution_texts: {}", e
                    )
                });
            self
        }
        pub fn comment<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .comment = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for comment: {}", e)
                });
            self
        }
        pub fn copyright_text<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .copyright_text = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for copyright_text: {}", e)
                });
            self
        }
        pub fn license_comments<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .license_comments = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for license_comments: {}", e
                    )
                });
            self
        }
        pub fn license_info_from_files<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .license_info_from_files = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for license_info_from_files: {}",
                        e
                    )
                });
            self
        }
        pub fn license_info_in_snippets<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .license_info_in_snippets = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for license_info_in_snippets: {}",
                        e
                    )
                });
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn ranges<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Spdx22DocumentSnippetsItemRangesItem>>,
            T::Error: std::fmt::Display,
        {
            self
                .ranges = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for ranges: {}", e)
                });
            self
        }
        pub fn snippet_from_file<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .snippet_from_file = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for snippet_from_file: {}", e
                    )
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx22DocumentSnippetsItem>
    for super::Spdx22DocumentSnippetsItem {
        type Error = String;
        fn try_from(value: Spdx22DocumentSnippetsItem) -> Result<Self, String> {
            Ok(Self {
                annotations: value.annotations?,
                attribution_texts: value.attribution_texts?,
                comment: value.comment?,
                copyright_text: value.copyright_text?,
                license_comments: value.license_comments?,
                license_info_from_files: value.license_info_from_files?,
                license_info_in_snippets: value.license_info_in_snippets?,
                name: value.name?,
                ranges: value.ranges?,
                snippet_from_file: value.snippet_from_file?,
            })
        }
    }
    impl From<super::Spdx22DocumentSnippetsItem> for Spdx22DocumentSnippetsItem {
        fn from(value: super::Spdx22DocumentSnippetsItem) -> Self {
            Self {
                annotations: Ok(value.annotations),
                attribution_texts: Ok(value.attribution_texts),
                comment: Ok(value.comment),
                copyright_text: Ok(value.copyright_text),
                license_comments: Ok(value.license_comments),
                license_info_from_files: Ok(value.license_info_from_files),
                license_info_in_snippets: Ok(value.license_info_in_snippets),
                name: Ok(value.name),
                ranges: Ok(value.ranges),
                snippet_from_file: Ok(value.snippet_from_file),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx22DocumentSnippetsItemAnnotationsItem {
        annotation_date: Result<Option<String>, String>,
        annotation_type: Result<
            Option<super::Spdx22DocumentSnippetsItemAnnotationsItemAnnotationType>,
            String,
        >,
        annotator: Result<Option<String>, String>,
        comment: Result<Option<String>, String>,
    }
    impl Default for Spdx22DocumentSnippetsItemAnnotationsItem {
        fn default() -> Self {
            Self {
                annotation_date: Ok(Default::default()),
                annotation_type: Ok(Default::default()),
                annotator: Ok(Default::default()),
                comment: Ok(Default::default()),
            }
        }
    }
    impl Spdx22DocumentSnippetsItemAnnotationsItem {
        pub fn annotation_date<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .annotation_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for annotation_date: {}", e)
                });
            self
        }
        pub fn annotation_type<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Option<super::Spdx22DocumentSnippetsItemAnnotationsItemAnnotationType>,
            >,
            T::Error: std::fmt::Display,
        {
            self
                .annotation_type = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for annotation_type: {}", e)
                });
            self
        }
        pub fn annotator<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .annotator = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for annotator: {}", e)
                });
            self
        }
        pub fn comment<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .comment = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for comment: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx22DocumentSnippetsItemAnnotationsItem>
    for super::Spdx22DocumentSnippetsItemAnnotationsItem {
        type Error = String;
        fn try_from(
            value: Spdx22DocumentSnippetsItemAnnotationsItem,
        ) -> Result<Self, String> {
            Ok(Self {
                annotation_date: value.annotation_date?,
                annotation_type: value.annotation_type?,
                annotator: value.annotator?,
                comment: value.comment?,
            })
        }
    }
    impl From<super::Spdx22DocumentSnippetsItemAnnotationsItem>
    for Spdx22DocumentSnippetsItemAnnotationsItem {
        fn from(value: super::Spdx22DocumentSnippetsItemAnnotationsItem) -> Self {
            Self {
                annotation_date: Ok(value.annotation_date),
                annotation_type: Ok(value.annotation_type),
                annotator: Ok(value.annotator),
                comment: Ok(value.comment),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx22DocumentSnippetsItemRangesItem {
        end_pointer: Result<
            Option<super::Spdx22DocumentSnippetsItemRangesItemEndPointer>,
            String,
        >,
        start_pointer: Result<
            Option<super::Spdx22DocumentSnippetsItemRangesItemStartPointer>,
            String,
        >,
    }
    impl Default for Spdx22DocumentSnippetsItemRangesItem {
        fn default() -> Self {
            Self {
                end_pointer: Ok(Default::default()),
                start_pointer: Ok(Default::default()),
            }
        }
    }
    impl Spdx22DocumentSnippetsItemRangesItem {
        pub fn end_pointer<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Option<super::Spdx22DocumentSnippetsItemRangesItemEndPointer>,
            >,
            T::Error: std::fmt::Display,
        {
            self
                .end_pointer = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for end_pointer: {}", e)
                });
            self
        }
        pub fn start_pointer<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Option<super::Spdx22DocumentSnippetsItemRangesItemStartPointer>,
            >,
            T::Error: std::fmt::Display,
        {
            self
                .start_pointer = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for start_pointer: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx22DocumentSnippetsItemRangesItem>
    for super::Spdx22DocumentSnippetsItemRangesItem {
        type Error = String;
        fn try_from(
            value: Spdx22DocumentSnippetsItemRangesItem,
        ) -> Result<Self, String> {
            Ok(Self {
                end_pointer: value.end_pointer?,
                start_pointer: value.start_pointer?,
            })
        }
    }
    impl From<super::Spdx22DocumentSnippetsItemRangesItem>
    for Spdx22DocumentSnippetsItemRangesItem {
        fn from(value: super::Spdx22DocumentSnippetsItemRangesItem) -> Self {
            Self {
                end_pointer: Ok(value.end_pointer),
                start_pointer: Ok(value.start_pointer),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx22DocumentSnippetsItemRangesItemEndPointer {
        reference: Result<Option<String>, String>,
    }
    impl Default for Spdx22DocumentSnippetsItemRangesItemEndPointer {
        fn default() -> Self {
            Self {
                reference: Ok(Default::default()),
            }
        }
    }
    impl Spdx22DocumentSnippetsItemRangesItemEndPointer {
        pub fn reference<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .reference = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for reference: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx22DocumentSnippetsItemRangesItemEndPointer>
    for super::Spdx22DocumentSnippetsItemRangesItemEndPointer {
        type Error = String;
        fn try_from(
            value: Spdx22DocumentSnippetsItemRangesItemEndPointer,
        ) -> Result<Self, String> {
            Ok(Self {
                reference: value.reference?,
            })
        }
    }
    impl From<super::Spdx22DocumentSnippetsItemRangesItemEndPointer>
    for Spdx22DocumentSnippetsItemRangesItemEndPointer {
        fn from(value: super::Spdx22DocumentSnippetsItemRangesItemEndPointer) -> Self {
            Self {
                reference: Ok(value.reference),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Spdx22DocumentSnippetsItemRangesItemStartPointer {
        reference: Result<Option<String>, String>,
    }
    impl Default for Spdx22DocumentSnippetsItemRangesItemStartPointer {
        fn default() -> Self {
            Self {
                reference: Ok(Default::default()),
            }
        }
    }
    impl Spdx22DocumentSnippetsItemRangesItemStartPointer {
        pub fn reference<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self
                .reference = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for reference: {}", e)
                });
            self
        }
    }
    impl std::convert::TryFrom<Spdx22DocumentSnippetsItemRangesItemStartPointer>
    for super::Spdx22DocumentSnippetsItemRangesItemStartPointer {
        type Error = String;
        fn try_from(
            value: Spdx22DocumentSnippetsItemRangesItemStartPointer,
        ) -> Result<Self, String> {
            Ok(Self {
                reference: value.reference?,
            })
        }
    }
    impl From<super::Spdx22DocumentSnippetsItemRangesItemStartPointer>
    for Spdx22DocumentSnippetsItemRangesItemStartPointer {
        fn from(value: super::Spdx22DocumentSnippetsItemRangesItemStartPointer) -> Self {
            Self {
                reference: Ok(value.reference),
            }
        }
    }
}

